<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FQiqiM.github.io%2F2020%2F03%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[My New Post]]></title>
    <url>%2FQiqiM.github.io%2F2020%2F02%2F26%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[TEST CI1234567891011121314151617class Sleep &#123; constructor(timeout) &#123; this.timeout = timeout; &#125; then(resolve, reject) &#123; const startTime = Date.now(); setTimeout( () =&gt; resolve(Date.now() - startTime), this.timeout ); &#125;&#125;(async () =&gt; &#123; const sleepTime = await new Sleep(1000); console.log(sleepTime);&#125;)(); yyyyyyyyyyyyyyyyyyy]]></content>
  </entry>
  <entry>
    <title><![CDATA[模拟实现js的bind方法]]></title>
    <url>%2FQiqiM.github.io%2F2020%2F02%2F26%2F%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0js%E7%9A%84bind%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[123456var obj = &#123;&#125;;console.log(obj);console.log(typeof Function.prototype.bind); // functionconsole.log(typeof Function.prototype.bind()); // functionconsole.log(Function.prototype.bind.name); // bindconsole.log(Function.prototype.bind().name); // bound bind是什么 a. bind 是Function原型链中Function.prototype的一个函数，每个函数都可以调用它。 b. bind本身是一个函数名为bind的函数，返回值也是函数，函数名是bound。(console出来为 bound加上一个空格)。 1234567891011121314151617181920let obj = &#123; name: "yato"&#125;function original(a,b)&#123; console.log(this.name) console.log([a,b]) return false&#125;let bound = original.bind(obj, 1)let boundInvoke = bound(2) // 'yato', Array(2)[1,2]console.log(boundInvoke) // falseconsole.log(original.bind.name) // bindconsole.log(original.bind.length) // 1console.log(original.bind().length) // 2 返回original函数形参个数console.log(bound.name) // 'bound original'console.log((function()&#123;&#125;).bind().name) // 'bound 'console.log((function()&#123;&#125;).bind().length) // 0 2. 进一步理解bind a. 调用bind的函数中的this指向bind()函数的第一个参数。 b. 函数bind()时传递的参数被bind接受处理，bind()完毕之后，程序调用返回的函数（bound）时，传递的参数也接收处理了，也就是在bind()内部合并处理了。 c. 并且bind()后的函数的name为bound+空格+调用bind的函数名。如果调用函数为匿名函数，则名字为bound+空格 d. bind后的返回值函数，执行后返回值时原函数（original）的返回值（上例中的false） e. bind函数的形参（即函数的length）是1。bind后返回的bound函数形参不定，根据绑定的函数原函数（original）形参个数决定。 3.根据上面的两个例子，模拟实现一个简单版的bindFn123456789101112131415161718192021222324252627282930313233Function.prototype.bindFn = function bindFake(thisArg)&#123; if(typeof this !== 'function')&#123; throw new TypeError(this + 'must be a function') &#125; // 存储函数本身 let self = this // 去除thisArg的其他参数，转成数组 let args = [].slice.call(arguments, 1) let bound = function()&#123; // bind 返回的函数，也就是bound，在程序中被调用时传递的参数转成数组 let boundArg = [].slice.call(arguments); // apply修改this指向，把两个函数的参数合并传给self函数，返回执行结果 return self.apply(thisArg, args.concat(boundArg)) &#125; return bound&#125;// Testlet obj = &#123; name: 'yato'&#125;function original(a, b)&#123; console.log(this.name) console.log([a,b])&#125;let bound = original.bindFn(obj, 1)bound(2); // 'yato', [1,2] 4.但是函数是可以使用new来实例化的。1234567891011121314let obj = &#123;name : 'yato'&#125;function original(a, b)&#123; console.log('this : ', this) console.log('typeof this : ', typeof this) this.name = b console.log('name: ', this.name) console.log('this: ', this) console.log([a,b])&#125;let bound = original.bind(obj, 1)let newBoundInvoke = new bound(2)console.log('newBoundInvoke: ', newBoundInvoke) 分析例子可以得出结论 a. 从例子中可以看出this指向了new bound()生成的对象 b. new bound() 的返回值是以original原函数构造器生成的新对象。original原函数的this指向的就是这个新对象。 c.简要剖析下new做了什么 创建一个全新的空对象 对这个对象指向原型链接（instance.__proto__ = Class.prototype ），其实Class.prototype就是constructor 生成的新对象会绑定到函数调用的this 通过new创建的每个对象最终被[[prototype]]链接这个函数的prototype上（参考2） 如果函数没有返回对象类型Object(包含Function, Array, Date, RegExg, Error),那么new表达式中的函数调用会自动返回这个新的对象 4.1所有相当于在new调用时，bind的返回值函数bound内部要实现new的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 第二版 实现new调用Function.prototype.bindFn = function bindFake(thisArg)&#123; if(typeof this !== 'function')&#123; throw new TypeError(this + ' must be a function') &#125; // 存储调用bind的函数本身的引用 let self = this // 去除thisArg参数，其他转成数组 let args = [].slice.call(arguments, 1) let bound = function()&#123; let boundArgs = [].slice.call(arguments) let finalArgs = args.concat(boundArgs) // new 调用时，其实this instanceof bound 判断不是很准确。es6 // new.target就是解决这一问题的 if(this instanceof bound)&#123; // 这里是实现上文描述的 new 的第 1, 2, 4 步 // 1.创建一个全新的对象 // 2.并且执行[[Prototype]]链接 // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。 // self可能是ES6的箭头函数，没有prototype，所以就没必要再指向做prototype操作。 if(self.prototype)&#123; function Empty()&#123;&#125; Empty.prototype = self.prototype bound.prototype = new Empty() &#125; // 这里实现的时上文描述的第三步 // 3.生成的新对象会绑定到函数调用的this let result = self.apply(this, finalArgs); // 这里是实现上文描述的 new 的第 5 步 // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, // `Error`)， // 那么`new`表达式中的函数调用会自动返回这个新的对象。 let isObject = typeof result === 'object' &amp;&amp; result !== null let isFunction = typeof result === 'function' if(isObject || isFunction) return result return this &#125;else&#123; // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果 return self.apply(thisArg, finalArgs) &#125; &#125; return bound&#125;// Testlet obj = &#123;name : 'yato'&#125;function original(a, b)&#123; console.log('this : ', this) console.log('typeof this : ', typeof this) this.name = b console.log('name: ', this.name) console.log('this: ', this) console.log([a,b])&#125;let bound = original.bindFn(obj, 1)let newBoundInvoke = new bound(2)console.log('newBoundInvoke: ', newBoundInvoke) 5. 总结 bind是Function原型链中Function.prototype的一个属性，它是一个函数，修改this指向，合并参数传递给原函数，返回值是一个新的函数。 bind返回的函数可以通过new调用，这是提供的this参数被忽略，指向了new生成的全新对象。bind()内部模拟实现了new操作符]]></content>
      <tags>
        <tag>JS</tag>
        <tag>深入js系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++实现双向链表]]></title>
    <url>%2FQiqiM.github.io%2F2019%2F06%2F25%2FC%2B%2B%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。 C++实现双向链表双向链表头文件(LinkList.h)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223#pragma once#ifndef _LINK_LIST_H#define _LINK_LIST_H#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;struct DNode&#123; public: T value; DNode *prev; DNode *next; public: DNode() &#123;&#125; DNode(T t, DNode *prev, DNode *next) &#123; this-&gt;value = t; this-&gt;prev = prev; this-&gt;next = next; &#125;&#125;;template&lt;class T&gt;class DoubleLink &#123; public: DoubleLink(); ~DoubleLink(); int size(); int isEmpty(); T get(int index); T getFirst(); T getLast(); int insert(int index, T t); int insertFirst(T t); int appendLast(T t); int del(int index); int delFirst(); int delLast(); private: int count; DNode&lt;T&gt; *pHead; private: DNode&lt;T&gt; *getNode(int index);&#125;;template&lt;class T&gt;DoubleLink&lt;T&gt;::DoubleLink() : count(0)&#123; // 创建表头。注意：表头没有存储数据 pHead = new DNode&lt;T&gt;(); pHead-&gt;next = NULL;&#125;// 析构函数template&lt;class T&gt;DoubleLink&lt;T&gt;::~DoubleLink()&#123; // 删除所有结点 DNode&lt;T&gt;* pTemp; DNode&lt;T&gt;* pNode = pHead-&gt;next; while (pNode != pHead) &#123; pTemp = pNode; pNode = pNode-&gt;next; delete pTemp; &#125; // 删除表头 delete pHead; pHead = NULL;&#125;// 返回结点数目template&lt;class T&gt;int DoubleLink&lt;T&gt;::isEmpty()&#123; return count == 0;&#125;// 返回节点数目template &lt; class T&gt;int DoubleLink&lt;T&gt;::size()&#123; return count;&#125;// 获取index位置的结点template&lt;class T&gt;DNode&lt;T&gt;* DoubleLink&lt;T&gt;::getNode(int index)&#123; // 判断参数有效性 if (index &lt; 0 || index &gt;= count) &#123; cout &lt;&lt; " getNode failed! the index is out of round" &lt;&lt; endl; return NULL; &#125; // 正向查找， 查找优化，减少查找次数 if (index &lt;= count / 2) &#123; int i = 0; DNode&lt;T&gt;* pIndex = pHead-&gt;next; while (i++ &lt; index) &#123; pIndex = pIndex-&gt;next; &#125; return pIndex; &#125; // 反向查找 int j = 0; int rIndex = count - index - 1; DNode&lt;T&gt;* pRindex = pHead-&gt;prev; while (j++ &lt; rIndex) &#123; pRindex = pRindex-&gt;prev; &#125; return pRindex;&#125;// 获取第index位置的结点的值template&lt;class T&gt;T DoubleLink&lt;T&gt;::get(int index)&#123; return getNode(index)-&gt;value;&#125;// 获取第一个结点的值template&lt;class T&gt;T DoubleLink&lt;T&gt;::getLast()&#123; return getNode(count-1)-&gt;value;&#125;// 获取最后一个结点的值template&lt;class T&gt;T DoubleLink&lt;T&gt;::getFirst()&#123; return getNode(0)-&gt;value;&#125;// 将结点插入到第index位置之前template&lt;class T&gt;int DoubleLink&lt;T&gt;::insert(int index, T t)&#123; if (index == 0) return insertFirst(t); DNode&lt;T&gt;* pIndex = getNode(index); DNode&lt;T&gt;* pNode = new DNode&lt;T&gt;(t, pIndex-&gt;prev, pIndex); pIndex-&gt;prev-&gt;next = pNode; pIndex-&gt;prev = pNode; count++; return 0;&#125;// 将结点插入到第一个结点处template&lt;class T&gt;int DoubleLink&lt;T&gt;::insertFirst(T t)&#123; DNode&lt;T&gt;* pNode = new DNode&lt;T&gt;(t, pHead, pHead-&gt;next); // 构造函数时就已经指定结点的前驱和后继结点了 // 这里第一个结点的时候需要判断空指针 if (pHead-&gt;next == NULL) pHead-&gt;prev = pNode; else pHead-&gt;next-&gt;prev = pNode; pHead-&gt;next = pNode; count++; return 0;&#125;// 将结点追加到链表的末尾template&lt;class T&gt;int DoubleLink&lt;T&gt;::appendLast(T t)&#123; DNode&lt;T&gt;* pNode = new DNode&lt;T&gt;(t, pHead-&gt;prev, pHead); pHead-&gt;prev-&gt;next = pNode; pHead-&gt;prev = pNode; count++; return 0;&#125;// 删除index位置的结点template&lt;class T&gt;int DoubleLink&lt;T&gt;::del(int index)&#123; DNode&lt;T&gt;* pIndex = getNode(index); pIndex-&gt;next-&gt;prev = pIndex-&gt;prev; pIndex-&gt;prev-&gt;next = pIndex-&gt;next; delete pIndex; count--; return 0;&#125;// 删除第一个结点template&lt;class T&gt;int DoubleLink&lt;T&gt;::delFirst()&#123; return del(0);&#125;// 删除最后一个结点template&lt;class T&gt;int DoubleLink&lt;T&gt;::delLast()&#123; return del(count - 1);&#125; #endif // !_LINK_LIST_H 双向链表测试文件(LinkList.cpp)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include "pch.h"#include &lt;iostream&gt;#include &lt;string&gt;#include "LinkList.h"using namespace std;// 双向链表操作int数据void intTest()&#123; int intArr[4] = &#123; 10,20,30,40 &#125;; cout &lt;&lt; "\n -------------intTest------------" &lt;&lt; endl; // 创建双向链表 DoubleLink&lt;int&gt;* pDlinkList = new DoubleLink&lt;int&gt;(); pDlinkList-&gt;insert(0, 20); pDlinkList-&gt;appendLast(10); pDlinkList-&gt;insertFirst(30); pDlinkList-&gt;insert(1, 40); pDlinkList-&gt;delFirst(); // 双向链表是否为空 cout &lt;&lt; "isEmpty= " &lt;&lt; pDlinkList-&gt;isEmpty() &lt;&lt; endl; // 双向链表的长度 cout &lt;&lt; "size=" &lt;&lt; pDlinkList-&gt;size() &lt;&lt; endl; // 打印双向链表的全部数据 int length = pDlinkList-&gt;size(); for (int i = 0; i &lt; length; i++) &#123; cout &lt;&lt; "pDlinkList(" &lt;&lt; i &lt;&lt; ")=" &lt;&lt; pDlinkList-&gt;get(i) &lt;&lt; endl; &#125;&#125;void stringTest()&#123; string sArr[4] = &#123; "ten","tewnty","thirty","forty" &#125;; cout &lt;&lt; "\n------------stringTest-----------" &lt;&lt; endl; DoubleLink&lt;string&gt;* pDlinkList = new DoubleLink&lt;string&gt;(); pDlinkList-&gt;insert(0, sArr[1]); pDlinkList-&gt;appendLast(sArr[0]); pDlinkList-&gt;insertFirst(sArr[2]); // 双向链表是否为空 cout &lt;&lt; "isEmpty()=" &lt;&lt; pDlinkList-&gt;isEmpty() &lt;&lt; endl; // 双向链表的长度 cout &lt;&lt; "size=" &lt;&lt; pDlinkList-&gt;size() &lt;&lt; endl; // 打印双向链表的全部数据 int length = pDlinkList-&gt;size(); for (int i = 0; i &lt; length; i++) &#123; cout &lt;&lt; "pDlinkList(" &lt;&lt; i &lt;&lt; ")=" &lt;&lt; pDlinkList-&gt;get(i) &lt;&lt; endl; &#125;&#125;struct stu&#123; int id; char name[20];&#125;;static stu stuArr[] = &#123; &#123;10,"one"&#125;, &#123;20,"two"&#125;, &#123;30,"three"&#125;, &#123;40,"four"&#125;&#125;;#define ARR_STU_SIZE ((sizeof(stuArr)) / (sizeof(stuArr[0])))void objectTest()&#123; cout &lt;&lt; "\n------------stringTest-----------" &lt;&lt; endl; DoubleLink&lt;stu&gt;* pDlinkList = new DoubleLink&lt;stu&gt;(); pDlinkList-&gt;insert(0, stuArr[1]); pDlinkList-&gt;appendLast(stuArr[0]); pDlinkList-&gt;insertFirst(stuArr[2]); // 双向链表是否为空 cout &lt;&lt; "isEmpty()=" &lt;&lt; pDlinkList-&gt;isEmpty() &lt;&lt; endl; // 双向链表的长度 cout &lt;&lt; "size=" &lt;&lt; pDlinkList-&gt;size() &lt;&lt; endl; // 打印双向链表的全部数据 struct stu p; int length = pDlinkList-&gt;size(); for (int i = 0; i &lt; length; i++) &#123; p = pDlinkList-&gt;get(i); cout &lt;&lt; "pDlinkList(" &lt;&lt; i &lt;&lt; ")=[" &lt;&lt; p.id &lt;&lt;" ," &lt;&lt; p.name&lt;&lt;"]" &lt;&lt; endl; &#125;&#125;int main()&#123; intTest(); stringTest(); objectTest(); return 0;&#125; 此文实现参考,侵权必删，大佬的有一些错误，经过测试已经修改。]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>C++</tag>
        <tag>LinkList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法1-冒泡排序]]></title>
    <url>%2FQiqiM.github.io%2F2019%2F06%2F12%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%951--%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法原理 冒泡排序(Bubble Sort，也叫泡沫排序或气泡排序)，是一种简单的排序算法。它重复的走访过要排序的数列，一次比较两个元素，如果他们的顺序错误，将元素位置对调。走访数列的工作是重复进行的，直到再没有需要交换的数据，该数列排序完成。 冒泡排序算法的流程如下： 比较相邻的元素。如果第一个元素大于第二个元素，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数 针对所有的元素重复以上的步骤，除了最后一个元素（到最后一个元素，已经排好序了） 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 实例分析以数组arr = [5,2,6,9,3]为例说明，加粗的数字表示每次循环要比较的两个数字： 第一次外循环 ( 5 2 6 9 3 ) ==&gt; ( 2 5 6 9 3 ) | 5 &gt; 2 交换位置 ( 2 5 6 9 3 ) ==&gt; ( 2 5 6 9 3 ) | 5 &lt; 6 位置不变 ( 2 5 6 9 3 ) ==&gt; ( 2 5 6 9 3 ) | 6 &lt; 9 位置不变 ( 2 5 6 9 3 ) ==&gt; ( 2 5 6 3 9 ) | 9 &gt; 3 交换位置 第二次外循环 ( 2 5 6 3 9 ) ==&gt; ( 2 5 6 3 9 ) | 2 &lt; 3 位置不变 ( 2 5 6 3 9 ) ==&gt; ( 2 5 6 3 9 ) | 5 &lt; 6 位置不变 ( 2 5 6 3 9 ) ==&gt; ( 2 5 3 6 9 ) | 6 &gt; 3 交换位置 第三次外循环 ( 2 5 3 6 9 ) ==&gt; ( 2 5 3 6 9 ) | 2 &lt; 5 位置不变 ( 2 5 3 6 9 ) ==&gt; ( 2 3 5 6 9 ) | 5 &gt; 3 交换位置 第四次外循环（观察一下，其实此时已经排完序了，但是程序并不知道，所以仍要进行后续循环，直到剩余的序列为1） ( 2 3 5 6 9 ) ==&gt; ( 2 3 5 6 9 ) | 2 &lt; 5 位置不变 javaScript实现123456789101112131415161718let testArr = [5,2,6,9,3];function bubbleSort1(arr)&#123; let i,j,temp,l = arr.length; for(i = l- 1; i &gt; 0;i--)&#123; for(j = 0; j &lt; i;j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;bubbleSort1(testArr);console.log(testArr); // [ 2, 3, 5, 6, 9 ] 观察上面冒泡排序的流程，不需要到最后一步，就排序完成了，后面的循环就浪费了，可以设置个flag来使它的效率更高一些：添加一个标记，如果一趟遍历中发生了变换，则标记为true,否则为false.如果一趟没有发生交换，说明排序已经完成。 冒泡排序优化12345678910111213141516171819202122function bubbleSort2(arr)&#123; let i,j,temp,l = arr.length; let flag = 0; // 初始化flag为0 for(i = l- 1; i &gt; 0;i--)&#123; for(j = 0; j &lt; i;j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = 1; // 若发生交换，则标记为1 &#125; &#125; if(flag === 0) break; // 若没有发生交换，则说明数列已经有序 &#125;&#125;bubbleSort2(testArr);console.log(testArr); // [ 2, 3, 5, 6, 9 ]]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[屈原《渔父》]]></title>
    <url>%2FQiqiM.github.io%2F2018%2F12%2F19%2F%E5%B1%88%E5%8E%9F%E3%80%8A%E6%B8%94%E7%88%B6%E3%80%8B%2F</url>
    <content type="text"><![CDATA[转载自阮一峰老师的个人blog，侵权必删！原文链接 译文（大巧若工） 一个理想主义者痛苦地来到江边。在那里，他遇到了一个现实主义者。 现实问：“你为什么如此憔悴？” 理想答：“这个世界容不下我。我坚持的东西，其他人都无所谓；他们热衷的东西，我没有办法强迫自己加入。” 现实笑道：“老兄何必这么迂腐呢，别人怎么样，你也怎么样，不就可以了吗？他们脏，你也跟着一起脏，又何妨？像你这样自我孤立，真是自讨苦吃，不值得啊。” 理想说：“那我要问你，刚洗完头的人愿不愿意戴脏帽子，刚洗完澡的人愿不愿意穿脏衣服？干净的身体怎么能够甘心沾上灰尘呢？与其同流合污，不如选择孤独。” 现实指着面前的江水说：“你看这滔滔江水，如果水是清的，我就用它来洗衣服，活得干干净净；如果水是脏的，我就用它洗脚。人应该要学会适应。” 至此，两人就不再说话了。 《渔父》 —屈原 屈原既放，游于江潭，行吟泽畔；颜色憔悴，形容枯槁。 渔父见而问之曰：“子非三闾大夫与？何故至于斯？” 屈原曰：“举世皆浊我独清，众人皆醉我独醒，是以见放。” 渔父曰：“圣人不凝滞于物，而能与世推移。世人皆浊，何不淈其泥而扬其波？众人皆醉，何不铺其糟而歠其醨？何故深思高举，自令放为？” 屈原曰：“吾闻之：新沐者必弹冠，新浴者必振衣，安能以身之察察，受物之汶汶者乎？宁赴湘流，葬身于江鱼之腹中，安能以皓皓之白，而蒙世俗之尘埃乎？” 渔父莞尔而笑，鼓枻而去。歌曰：“沧浪之水清兮，可以濯吾缨；沧浪之水浊兮，可以濯吾足。”遂去，不复与言。]]></content>
      <tags>
        <tag>Article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[历史过程]]></title>
    <url>%2FQiqiM.github.io%2F2018%2F12%2F19%2F%E5%8E%86%E5%8F%B2%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[转载自阮一峰老师的个人blog,侵权必删！原文链接 小时候，政治课里经常说，事物发展有一个历史过程。当时只觉得是很普通的一句话，现在明白它的涵义了。 什么叫历史过程？就是无法避免的牺牲。 贵州某山区，漫山遍野的小冶炼作坊，青山绿水成了黑山污水。重金属离子渗入土地，癌症流行，儿童极易出现畸形和智力低下。但是无法关闭这些作坊，因为关了就没收入，所以当地人明知有毒也要干。近几年，有色金属价格暴涨，又不知有多少山河要被毁掉。可是没有办法，这叫历史过程。 小煤矿每年死这么多人，为什么降不下来？因为当地财政依赖采矿收入，政府根本下不了决心关；而矿工如果不去挖煤，就要沦落为流浪汉。这叫历史过程。 中华人民共和国建国后的发展，就是依靠强制低收入来实现国家资本积累。我们的父辈下乡、支内、进国有工厂，不就是用他们的一生为国家的原始积累做贡献嘛？他们的人生就这样被牺牲掉了。这叫历史过程。 一位英国历史学家说：“历史涉及的只是一个民族生活的极小部分。人民的大部分生活，过去和未来都不会有文字记载。” 历史过程无法避免，生命就这样无意义地牺牲和痛苦着。唯愿那些为历史做陪葬的人生不要被忘记。]]></content>
      <tags>
        <tag>Article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php array]]></title>
    <url>%2FQiqiM.github.io%2F2018%2F12%2F15%2Fphp-array%2F</url>
    <content type="text"><![CDATA[1.php中如何循环二维数组在php中，采用foreach循环来对二维索引数组进行遍历,下面的例子演示如何将三个关联数组，通过公有的key,在例子中是gid;组合成一个关联数组。 a.初始化数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061$paylist = array( 0=&gt;array( 'gid'=&gt; 1, 'money'=&gt; '100' ), 1=&gt;array( 'gid'=&gt; 1, 'money'=&gt; '200' ), 2=&gt;array( 'gid'=&gt; 4, 'money'=&gt; '300' ), 3=&gt;array( 'gid'=&gt; 6, 'money'=&gt; '400' ), );$rolelist = array( 0=&gt;array( 'gid'=&gt; 1, 'name'=&gt; 'xx1' ), 1=&gt;array( 'gid'=&gt; 2, 'name'=&gt; 'xx2' ), 2=&gt;array( 'gid'=&gt; 4, 'name'=&gt; 'xx4' ), 3=&gt;array( 'gid'=&gt; 6, 'name'=&gt; 'xx6' ), );$serverlist = array( 0=&gt;array( 'gid'=&gt; 1, 'servername'=&gt; 's1' ), 1=&gt;array( 'gid'=&gt; 2, 'servername'=&gt; 's2' ), 2=&gt;array( 'gid'=&gt; 4, 'servername'=&gt; 's4' ), 3=&gt;array( 'gid'=&gt; 6, 'servername'=&gt; 's4' ), );$gsidarr = array(1,1,4,6);//去重排序$gsidarr = array_unique($gsidarr);$gsidarr = array_values($gsidarr); b.构造数据(将公有key提取出来作为key值索引)12345678910111213141516171819202122$roleresult = array();foreach($rolelist as $key =&gt; $value)&#123; $roleresult[$value['gid']] = $value;&#125;echo '&lt;/br&gt;----'.json_encode($roleresult).'&lt;/br&gt;';foreach($roleresult as $k=&gt;$v)&#123; echo $v['name'].'==&gt;'.$v['gid'].'--&lt;/br&gt;'; //打印一下构造之后的数据&#125;// 构造之后的数据roleresult//&#123;"1":&#123;"gid":1,"name":"xx1"&#125;,"2":&#123;"gid":2,"name":"xx2"&#125;,"4":&#123;"gid":4,"name":"xx4"&#125;,"6":&#123;"gid":6,"name":"xx6"&#125;&#125;$serresult = array();foreach($serverlist as $key =&gt; $value)&#123; $serresult[$value['gid']] = $value;&#125;echo '&lt;/br&gt;----'.json_encode($serresult).'&lt;/br&gt;';foreach($serresult as $k=&gt;$v)&#123; echo $v['servername'].'==&gt;'.$v['gid'].'--&lt;/br&gt;';&#125;// 构造之后的数据serverresult// &#123;"1":&#123;"gid":1,"servername":"s1"&#125;,"2":&#123;"gid":2,"servername":"s2"&#125;,"4":&#123;"gid":4,"servername":"s4"&#125;,"6":&#123;"gid":6,"servername":"s4"&#125;&#125; c.将构造好的数据组合起来(通过公有key来取roleresult和serverresult的value)1234567891011121314151617181920$ret = array();foreach($paylist as $v)&#123; $data = array( 'money'=&gt;$v['money'], 'gid'=&gt;$v['gid'], 'name'=&gt;$roleresult[$v['gid']]['name'], 'servername'=&gt;$serresult[$v['gid']]['servername'] ); array_push($ret,$data);&#125;//组装好之后的数据/* [&#123;"money":"100","gid":1,"name":"xx1","servername":"s1"&#125;,&#123;"money":"200", "gid":1,"name":"xx1","servername":"s1"&#125;,&#123;"money":"300","gid":4, "name":"xx4","servername":"s4"&#125;,&#123;"money":"400","gid":6,"name":"xx6", "servername":"s4"&#125;]*/echo '&lt;/br&gt;----'.json_encode($ret).'&lt;/br&gt;'; 2.最后附一个在线测试代码的网站在线测试网站]]></content>
      <tags>
        <tag>php</tag>
        <tag>array</tag>
      </tags>
  </entry>
</search>
