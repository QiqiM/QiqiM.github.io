[{"title":"再次理解事件循环（Event Loop）","date":"2020-07-29T07:58:01.000Z","path":"2020/07/29/深入js系列/再次理解事件循环/","text":"[toc] 1. 事件循环JavaScript 是单线程运行，异步操作特别重要。 只要用到引擎之外的功能，就需要跟外部交互，从而形成异步操作。由于异步操作实在太多，JavaScript 不得不提供很多异步语法。这就好比，有些人老是受打击， 他的抗打击能力必须变得很强，否则他就完蛋了。 Node 的异步语法比浏览器更复杂，因为它可以跟内核对话，不得不搞了一个专门的库 libuv 做这件事。这个库负责各种回调函数的执行时间，毕竟异步任务最后还是要回到主线程，一个个排队执行。 image 为了协调异步任务，Node 居然提供了四个定时器，让任务可以在指定的时间运行。 setTimeout() setInterval() setImmediate() process.nextTick() 前两个是语言的标准，`后两个是 Node 独有的。它们的写法差不多，作用也差不多，不太容易区别 2.同步任务和异步任务同步任务即正常业务代码，不含回调 123456789101112131415161718// test.jssetTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));new promise(()=&gt;&#123; console.log(4)&#125;)Promise.resolve().then(() =&gt; console.log(5));(() =&gt; console.log(6))();/*结果463512*/ 同步任务总比异步任务任务先执行 上面代码中只有以下两行代码是同步代码，所有最先执行，输4，612345new Promise(()=&gt;&#123; console.log(4)&#125;)Promise.resolve().then(() =&gt; console.log(5));(() =&gt; console.log(6))(); 异步任务可以分成两种： 追加在本轮循环的异步任务 追加在次轮循环的异步任务 循环指的是事件循环（EventLoop），本轮循环一定比次轮循环先执行 Node 规定，process.nextTick和Promise的回调函数，追加在本轮循环,同步任务执行结束完(优先级process.nextTick&gt;promise.then())，即同步任务一旦执行完成，就开始执行它们。而setTimeout、setInterval、setImmediate的回调函数，追加在次轮循环。 123456// 下面两行，次轮循环执行setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));// 下面两行，本轮循环执行process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(5)); 3.process.nextTick()虽然名字看起来像是次轮循环，实际上是追加在本次循环。 image Node执行完所有的同步任务后，就会立马执行process.nextTick的任务队列（nextTickQueue）,所以下面这行代码是第三个输出结果。基本上，如果你希望任务尽可能快的执行，那就使用process.nextTick() 1process.nextTick(() =&gt; console.log(3)); 4.微任务根据语言规定，Promise对象的回调函数，会进入异步任务里面的“微任务队列”(microtask)。微任务队列追加在process.nextTick队列后面。也属于本轮循环，所以以下代码总是先输出3在输出5 1234process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(5));// 3// 5 image 注意:只有一个队列趣步清空了以后，才会执行下一个队列。 12345678process.nextTick(() =&gt; console.log(1));Promise.resolve().then(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));// 1// 3// 2// 4 上面代码中，全部process.nextTick()的回调函数，都会早于Promise的。 综上，本轮循环的执行顺序为 1.同步任务 2.process.nextTick() 微任务 5.事件循环的概念Node文档官方定义如下 123456789When Node.js starts, it initializes the event loop, processes the provided inputscript which may make async API calls, schedule timers, or call process.nextTick(),then begins processing the event loop.当Node.js启动时，它将初始化事件循环，处理提供的输入脚本，该输入脚本可能进行异步API调用，调度计时器或调用process.nextTick（），然后开始处理事件循环。 这段话很重重要，首先，有的人认为，除了主线程，还存在一个单独的事件循环线程。不是这样的，只有一个主线程，事件循环是在主线程上完成的。其次，Node开始执行脚本时，会先进行事件循环的初始化，但是此时事件循环还没有开始，会先完成以下工作 同步任务 发出异步请求 规定定时器生效的时间 执行process.nextTick()等等 最后，上面这些事情都干完了，事件循环就开始了。 6.事件循环的六个阶段事件循环会无限次执行，一轮又一轮，只有异步任务的回调函数队列清空了，才会停止执行。每一轮的事件循环都分成六个阶段，这些阶段会依次执行 1234561. timers2. I/O callbacks3. idle, prepare4. poll5. check6. close callbacks 每一个阶段都有一个先进先出的回调函数队列，只有一个阶段的回调函数队列清空了，该执行的回调函数都执行了，事件循环才会进入下一个阶段。 image image 下面简单介绍一下每个阶段的含义，详细介绍可以看官方文档，也可以参考 libuv 的源码解读。 1. Timer这个是定时器阶段，处理setTimeOut()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段，进行下一阶段 2. I/O callbacks除了以下操作的的回调函数，其他回调函数都在这个阶段执行。 setTimeOut()和setInterval()的回调函数 setImmediate()的回调函数 用于关闭请求的回调函数，比如socket.on(&#39;close&#39;,...) 3. idle, prepare该阶段只供 libuv 内部调用，这里可以忽略。 4. Poll1）执行下限时间已经达到的timers的回调， 2）然后处理 poll 队列里的事件。当event loop进入 poll 阶段，并且 没有设定的 timers（there are no timers scheduled），会发生下面两件事之一： 如果 poll 队列不空，event loop会遍历队列并同步执行回调，直到队列清空或执行的回调数到达系统上限； 如果 poll 队列为空，则发生以下两件事之一： 如果代码已经被setImmediate()设定了回调, event loop将结束 poll 阶段进入 check 阶段来执行 check 队列（里面的回调 callback）。如果代码没有被setImmediate()设定回调，event loop将阻塞在该阶段等待回调被加入 poll 队列，并立即执行。 但是，当event loop进入 poll 阶段，并且 有设定的timers，一旦 poll 队列为空（poll 阶段空闲状态）：event loop将检查timers,如果有1个或多个timers的下限时间已经到达，event loop将绕回 timers 阶段，并执行 timer 队列。 快乐叮当 5. check该阶段执行setImmediate()的回调函数。 6. close callbacks该阶段执行关闭请求的回调函数，比如socket.on(‘close’, …)。 7.事件循环的例子123456789101112131415161718192021const fs = require('fs');const timeoutScheduled = Date.now();// 异步任务一：100ms 后执行的定时器setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms`);&#125;, 100);// 异步任务二：文件读取后，有一个 200ms 的回调函数fs.readFile('map.js', () =&gt; &#123; const startCallback = Date.now(); console.log(`read time: $&#123;startCallback -timeoutScheduled&#125;ms`) while (Date.now() - startCallback &lt; 200) &#123; // 什么也不做 &#125;&#125;);// read time: 2ms// 202ms 上面代码有两个异步任务，一个是 100ms 后执行的定时器，一个是文件读取，它的回调函数需要 200ms。请问运行结果是什么？ image 脚本进入第一轮事件循环以后，没有到期的定时器，也没有已经可以执行的 I/O 回调函数，所以会进入 Poll 阶段，等待内核返回文件读取的结果。由于读取小文件一般不会超过 100ms，所以在定时器到期之前，Poll 阶段就会得到结果，因此就会继续往下执行。 第二轮事件循环，依然没有到期的定时器，但是已经有了可以执行的 I/O 回调函数，所以会进入 I/O callbacks 阶段，执行fs.readFile的回调函数。这个回调函数需要 200ms，也就是说，在它执行到一半的时候，100ms 的定时器就会到期。但是，必须等到这个回调函数执行完，才会离开这个阶段。 第三轮事件循环，已经有了到期的定时器，所以会在 timers 阶段执行定时器。最后输出结果大概是200多毫秒。 8. setTimeout 和 setImmediate由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行。所以，setTimeout会早于setImmediate完成。 12setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2)); 上面代码应该先输出 1，再输出2，但是实际执行的时候，结果却是不确定，有时还会先输出2，再输出1。 这是因为setTimeout的第二个参数默认为0。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，根据官方文档，第二个参数的取值范围在1毫秒到2147483647毫秒(2^31 -1)之间。也就是说，setTimeout(f, 0)等同于setTimeout(f, 1)。 实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。 但是，下面的代码一定是先输出2，再输出1。 123456const fs = require(&apos;fs&apos;);fs.readFile(&apos;test.js&apos;, () =&gt; &#123; setTimeout(() =&gt; console.log(1)); setImmediate(() =&gt; console.log(2));&#125;); 上面代码会先进入I/O callbacks 阶段，然后是check 阶段，最后才是timers 阶段。因此，setImmediate才会早于setTimeout执行。 9.部分面试题 process.nextTick + setImmediate 1234567891011121314setImmediate(function () &#123; console.log(1); process.nextTick(function () &#123; console.log(2); &#125;);&#125;);process.nextTick(function () &#123; console.log(3); setImmediate(function () &#123; console.log(4); &#125;)&#125;);// 3 1 2 4 2 12345678setTimeout(function () &#123;console.log(1)Promise.resolve().then(() =&gt; console.log(3))process.nextTick(() =&gt; console.log(4))&#125;, 0);setImmediate(() =&gt; console.log(2))// 1 4 3 2 这个是因为netxtTick任务见缝插针，每个阶段完成都会查询。promise.then只会每轮查询。 312345678910111213141516171819202122232425262728293031323334353637383940async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end') &#125;async function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout0') &#125;,0) setTimeout(function()&#123; console.log('setTimeout3') &#125;,3) setImmediate(() =&gt; console.log('setImmediate'));process.nextTick(() =&gt; console.log('nextTick'));async1();new Promise(function(resolve)&#123; console.log('promise1') resolve(); console.log('promise2')&#125;).then(function()&#123; console.log('promise3')&#125;)console.log('script end')/* script startasync1 startasync2promise1promise2script endnextTickasync1 endpromise3setTimeout0setTimeout3setImmediate */ 412345678910111213141516171819202122232425262728293031323334setTimeout(() =&gt; &#123; console.log('timeout0'); new Promise((resolve, reject) =&gt; &#123; resolve('resolved') &#125;). then(res =&gt; console.log(res)); new Promise((resolve, reject) =&gt; &#123; setTimeout(()=&gt;&#123; resolve('timeout resolved') &#125;) &#125;).then(res =&gt; console.log(res)); process.nextTick(() =&gt; &#123; console.log('nextTick1'); process.nextTick(() =&gt; &#123; console.log('nextTick2'); &#125;); &#125;); process.nextTick(() =&gt; &#123; console.log('nextTick3'); &#125;); console.log('sync'); setTimeout(() =&gt; &#123; console.log('timeout2'); &#125;, 0);&#125;, 0);/*timeout0syncnextTick1nextTick3nextTick2resolvedtimeout resolvedtimeout2*/ 5.process.nextTick()导致程序饿死12345678910111213141516171819202122232425262728293031323334const fs = require('fs');function addNextTickRecurs(count) &#123; let self = this; if (self.id === undefined) &#123; self.id = 0; &#125; if (self.id === count) return; process.nextTick(() =&gt; &#123; console.log(`process.nextTick call $&#123;++self.id&#125;`); addNextTickRecurs.call(self, count); &#125;);&#125;addNextTickRecurs(Infinity);setTimeout(console.log.bind(console, 'omg! setTimeout was called'), 10);setImmediate(console.log.bind(console, 'omg! setImmediate also was called'));fs.readFile(__filename, () =&gt; &#123; console.log('omg! file read complete callback was called!');&#125;);console.log('started');/*process.nextTick call 1process.nextTick call 2process.nextTick call 3process.nextTick call 4process.nextTick call 5...*/ process.nextTick()的nextTickQueue在每个阶段执行完都会检查执行一次,并且在nextTick里增加的nextTick会直接添加到nextTickQueue队列里 12345678910111213141516171819202122232425262728293031323334353637setImmediate(() =&gt; console.log('this is set immediate 1'));setImmediate(() =&gt; console.log('this is set immediate 2'));setImmediate(() =&gt; console.log('this is set immediate 3'));setTimeout(() =&gt; console.log('this is set timeout 1'), 0);setTimeout(() =&gt; &#123; console.log('this is set timeout 2'); process.nextTick(() =&gt; console.log('this is process.nextTick added inside setTimeout'));&#125;, 0);setTimeout(() =&gt; console.log('this is set timeout 3'), 0);setTimeout(() =&gt; console.log('this is set timeout 4'), 0);setTimeout(() =&gt; console.log('this is set timeout 5'), 0);process.nextTick(() =&gt; console.log('this is process.nextTick 1'));process.nextTick(() =&gt; &#123; process.nextTick(console.log.bind(console, 'this is the inner next tick inside next tick'));&#125;);process.nextTick(() =&gt; console.log('this is process.nextTick 2'));process.nextTick(() =&gt; console.log('this is process.nextTick 3'));process.nextTick(() =&gt; console.log('this is process.nextTick 4'));/*this is process.nextTick 1this is process.nextTick 2this is process.nextTick 3this is process.nextTick 4this is the inner next tick inside next tickthis is set timeout 1this is set timeout 2this is process.nextTick added inside setTimeoutthis is set timeout 3this is set timeout 4this is set timeout 5this is set immediate 1this is set immediate 2this is set immediate 3*/ 7.process.nextTick和Promise的回调函数 原文解释 1234567891011121314151617181920212223242526272829303132333435Promise.resolve().then(() =&gt; console.log('promise1 resolved'));Promise.resolve().then(() =&gt; console.log('promise2 resolved'));Promise.resolve().then(() =&gt; &#123; console.log('promise3 resolved'); process.nextTick(() =&gt; console.log('next tick inside promise resolve handler'));&#125;);Promise.resolve().then(() =&gt; console.log('promise4 resolved'));Promise.resolve().then(() =&gt; console.log('promise5 resolved'));setImmediate(() =&gt; console.log('set immediate1'));setImmediate(() =&gt; console.log('set immediate2'));process.nextTick(() =&gt; console.log('next tick1'));process.nextTick(() =&gt; console.log('next tick2'));process.nextTick(() =&gt; console.log('next tick3'));setTimeout(() =&gt; console.log('set timeout'), 0);setImmediate(() =&gt; console.log('set immediate3'));setImmediate(() =&gt; console.log('set immediate4'));/*next tick1next tick2next tick3promise1 resolvedpromise2 resolvedpromise3 resolvedpromise4 resolvedpromise5 resolvednext tick inside promise resolve handlerset timeoutset immediate1set immediate2set immediate3set immediate4*/","tags":[{"name":"JS","slug":"JS","permalink":"https://github.com/QiqiM/tags/JS/"},{"name":"深入js系列","slug":"深入js系列","permalink":"https://github.com/QiqiM/tags/深入js系列/"}]},{"title":"外观模式","date":"2020-07-12T04:00:01.000Z","path":"2020/07/12/设计模式/外观模式/","text":"外观模式的定义 要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用。（简而言之就是提供一个统一的接口，用来 访问子系统的一群接口，从而让子系统更加容易使用） 使用场合 为一个复杂的模块或子系统提供一个外界访问的接口 子系统相对独立，外界对子系统的访问只要黑箱操作即可 维护一个大型遗留系统的时候，如果这个系统已经非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facede 类交互，提高复用性 当系统需要分层设计时，可以考虑使用Facade 模式 优缺点 优点： 使复杂子系统的接口变的简单可用，减少了客户端对子系统的以来，达到解耦的效果；让子系统内部的模块更易维护和扩展；遵循迪米特法则，对内封装具体细节，对外只暴露必要的接口 缺点：不符合开闭原则，如果要修改某一个子系统的功能，通常外观类也要一起修改 代码实现1234567891011121314151617181920212223242526272829303132class subSystemA &#123; doSonmeThing() &#123; console.log(\"sub system A operation\"); &#125;&#125;class subSystemB &#123; doSonmeThing() &#123; console.log(\"sub system B operation\"); &#125;&#125;class Facade &#123; constructor() &#123; this.subSystemA = new subSystemA(); this.subSystemB = new subSystemB(); &#125; doSonmeThing() &#123; this.subSystemA.doSonmeThing(); this.subSystemB.doSonmeThing(); &#125;&#125;function main() &#123; let facade = new Facade(); facade.doSonmeThing();&#125;main();// sub system A operation// sub system B operation","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://github.com/QiqiM/tags/结构型模式/"}]},{"title":"组合模式","date":"2020-07-12T04:00:01.000Z","path":"2020/07/12/设计模式/组合模式/","text":"组合模式组合模式的定义 也叫合成模式或部分-整体模式，主要用来描述部分和整体的关系，将对象组合成树形结构以表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 使用场合 维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理 优缺点 优点： 调用简单，只需要面对一致的对象而不用考虑整体部分或者叶子节点的问题；扩展性强，一方面，当更改组合对象的时候，只需要调整内部的层次关系，用户不用做出任何改动，另一方面，容易增加节点，只要找到他的父节点即可 缺点： 要求较高的抽象性，如果节点和叶子节点有很多差异的话（比如很多方法和属性不一样），不适合使用组合模式。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// 基类class Component &#123; constructor(name) &#123; this.name = name; &#125; add(component) &#123;&#125; remove(component) &#123;&#125; getChildren() &#123; return []; &#125;&#125;class Composite extends Component &#123; // 构件容器 constructor(name) &#123; super(name); this.componentList = []; &#125; doOperation() &#123; console.log(`这是容器$&#123;this.name&#125;，处理一些逻辑业务！`); &#125; add(component) &#123; this.componentList.push(component); &#125; remove(component) &#123; const componentIndex = this.componentList.findIndex((value, index) =&gt; &#123; return value == component; &#125;); this.componentList.splice(componentIndex, 1); &#125; getChildren() &#123; return this.componentList; &#125;&#125;class Leaf extends Component &#123; constructor(name) &#123; super(name); &#125; doOperation() &#123; console.log(`这是叶子节点$&#123;this.name&#125;，处理一些逻辑业务！`); &#125;&#125;function main() &#123; const root = new Composite(\"root\"); const node1 = new Leaf(\"1\"); const node2 = new Composite(\"2\"); const node3 = new Leaf(\"3\"); root.add(node1); root.add(node2); root.add(node3); const node2_1 = new Leaf(\"2_1\"); node2.add(node2_1); const children1 = root.getChildren(); console.log(children1); console.log(\"=============================\"); root.remove(node2); const children2 = root.getChildren(); console.log(children2);&#125;main();// [ Leaf &#123; name: '1' &#125;,// Composite &#123; name: '2', componentList: [ [Leaf] ] &#125;,// Leaf &#123; name: '3' &#125; ]// =============================// [ Leaf &#123; name: '1' &#125;, Leaf &#123; name: '3' &#125; ]","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://github.com/QiqiM/tags/结构型模式/"}]},{"title":"适配器模式","date":"2020-07-11T10:18:01.000Z","path":"2020/07/11/设计模式/适配器模式/","text":"适配器模式的定义 将一个类的接口变换为客户端所期待的另一种接口，从而使原本因为接口不匹配而无法在一起工作的两个类能够在一起工作 使用场合 整合第三方SDK 封装旧接口 类适配器和对象适配器：接口不符合规范，通过适配后变成符合规范的接口进行使用 接口适配器：适用于一个接口不想使用其所有的方法的情况 优缺点 优点： 让两个没关系类可以一起运行；提高类的复用性（源角色在原有系统里还可以使用） 缺点： 额外对象的创建，非直接调用，存在一定的开销； 不支持多重继承的语言一次只能适配一个适配者类，而且目标抽象类只能为接口，有一定的局限性；被适配者类的方法在Adapter中都会暴露出来 名词解释 Target: 目标角色，定义把其他类转换为何种接口 Adaptee: 被适配者，就是源角色 Adapter: 适配器，负责将Adaptee的接口转换为Target的接口 代码实现12345678910111213141516171819202122232425262728293031323334353637// 目标对象,接口或者抽象类 , 定义客户端调用的统一接口，// 适配器中需要实现抽象方法class Target &#123; constructor() &#123; if (new.target === User) &#123; throw new Error('抽象类不能实例化!') &#125; &#125; request() &#123; &#125;&#125;// 被适配者class Adaptee &#123; constructor() &#123;&#125; specificRequest() &#123; console.log(\"Adaptee request !\"); &#125;&#125;// 继承并实现接口的 request方法 （implements Target）// TS 才有implements，暂时直接在适配器中实现目标类的方法class Adapter extends Adaptee &#123; constructor() &#123; super(); &#125; request() &#123; super.specificRequest(); &#125;&#125;const target = new Adapter();target.request(); // Adaptee request !","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://github.com/QiqiM/tags/结构型模式/"}]},{"title":"桥接模式","date":"2020-07-11T09:00:01.000Z","path":"2020/07/11/设计模式/桥接模式/","text":"桥接模式的定义 桥接模式（Bridge）将抽象部分与它的实现部分分离，使他们都可以独立变化。 使用场合 不希望使用继承或者因为多继承导致类爆炸的系统； 优缺点 优点： 实现了抽象与实现部分的分离，提高了系统的灵活性；替代了多层继承方案，减少了子类的个数 缺点： 增加了系统的复杂度；要求正确识别出系统中两个独立变化的维度，适用范围有一定的局限性 桥接模式主要有4个角色组成： 抽象类 扩充抽象类 实现类接口 具体实现类 根据javascript语言的特点，我们将其简化成2个角色： 扩充抽象类 具体实现类 最简单的桥接模式其实我们最经常用的jQuery的each函数就是一个典型的桥接模式，我们模拟其实现如下： 123456789101112var each = function (arr, fn) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; var val = arr[i]; if (fn.call(val, i, val, arr)) &#123; return false; &#125; &#125;&#125;var arr = [1, 2, 3, 4];each(arr, function (i, v) &#123; arr[i] = v * 2;&#125;) 在这个例子中，我们通过函数循环了arr数组。在这个例子中，抽象部分是each()函数，也就是上面的扩充抽象类，实现部分就是function(i,v){},即具体实现类。抽象部分和实现部分可以独立的进行变化。这个例子虽然简单，但是一个典型的桥接模式的应用。 插件开发中的桥接模式桥接模式的一个使用场景是组件开发，我们平时开发组件为了适应不同场合，组件相应的会有许多不同维度的变化。桥接模式就可以应用于此，将抽象与实现分离，是组件的扩展性更高。假设我们要开发一个弹窗插件，弹窗有不同的类型:普通消息提醒，错误提醒，每一种提醒的展示方式还都不一样。这是一个典型的多维度变化的场景。首先我们定义两个类:普通消息弹窗和错误消息弹窗 123456789101112131415161718192021class Base &#123; constructor(animation) &#123; this.animation = animation; &#125; show() &#123; this.animation.show(); &#125;&#125;class MessageDialog extends Base &#123; constructor(animation) &#123; super(animation); &#125;&#125;class ErrorDialog extends Base &#123; constructor(animation) &#123; super(animation); &#125;&#125; 这两个类就是前面提到的抽象部分，也就是扩充抽象类，他们都包含一个成员animation。两种弹窗通过show方法进行展示，但是显示的动画效果不同。我们定义两种效果类如下：123456789101112131415class LineAnimation &#123; constructor() &#123;&#125; show() &#123; console.log(\"it is liner\"); &#125;&#125;class EaseAnimation &#123; constructor() &#123;&#125; show() &#123; console.log(\"it is ease\"); &#125;&#125; 这两个类就是具体实现类，它们实现具体的显示效果。使用方式如下1234let message = new MessageDialog(new LineAnimation());message.show();let errorMsg = new ErrorDialog(new EaseAnimation());errorMsg.show(); 总结学习桥接模式关键是要理解抽象部分与实现部分的分离，使得二者可以独立的变化，而不必拘泥于形式。JS插件灵活的变化，适应场景的多变就非常适合这种模式来实现。使用桥接模式最重要的是找出系统中的不同的变化维度。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://github.com/QiqiM/tags/结构型模式/"}]},{"title":"职责链模式","date":"2020-07-08T08:18:11.000Z","path":"2020/07/08/设计模式/职责链模式/","text":"职责链模式的定义使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 简单职责链模式故事背景：用户可以支付定金购买手机，并且可以获得优惠券。没有支付定金的就是普通用户，进入普通购买模式，没有优惠券，且库存不足的情况下不一定能够买到手机。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * * @param orderType 订单类型 * @param pay 用户是否已经支付过定金 true or false * @param stock 表示手机的库存量 */var order = function (orderType, pay, stock)&#123; if (orderType === 1) &#123; if (pay === true) &#123; console.log('500定金预购,得到100元优惠券'); &#125; else &#123; if (stock &gt; 0) &#123; console.log('普通购买,没有优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125; &#125; &#125; else if (orderType === 2) &#123; if (pay === true) &#123; console.log('200定金预购,得到50元优惠券'); &#125; else &#123; if (stock &gt; 0) &#123; console.log('普通购买,没有优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125; &#125; &#125; else if (orderType === 3) &#123; if (stock &gt; 0) &#123; console.log('普通购买,没有优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125; &#125;&#125;; 职责链重构上面的代码 主要通过拆分功能语句，来使用职责链重构:123456789101112131415161718192021222324252627282930313233//500元订单var order500 = function (orderType, pay, stock)&#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500定金预购,得到100元优惠券'); &#125; else &#123; order200(orderType, pay, stock); //将请求传递给200 &#125;&#125;;//200元订单var order200 = function (orderType, pay, stock)&#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log('200定金预购,得到50元优惠券'); &#125; else &#123; order(orderType, pay, stock); &#125;&#125;;//普通购买订单var order = function (orderType, pay, stock)&#123; if (stock&gt;0) &#123; console.log('普通购买,没有优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125;&#125;;//测试调用order500(1,true,500);order500(3,false,0); 总结：上面的代码违反了开放-封闭的原则，请求在链条中传递的顺序非常僵硬，传递请求的代码被耦合在了业务函数中： 12345678var order500 = function (orderType, pay, stock)&#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500定金预购,得到100元优惠券'); &#125; else &#123; order200(orderType, pay, stock); //将请求传递给200 &#125;&#125;; 灵活的拆分职责链节点为什么要拆分职责链的节点，因为某天需要添加新的职责，就需要修改业务代码（要修改的话，就需要先去了解他，熟悉它，花费大量的时间）。这显然不是每一个人所需要的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//500元订单var order500 = function (orderType, pay, stock)&#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500定金预购,得到100元优惠券'); &#125; else &#123; return 'nextSuccessor'; &#125;&#125;;//200元订单var order200 = function (orderType, pay, stock)&#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log('200定金预购,得到50元优惠券'); &#125; else &#123; return 'nextSuccessor'; &#125;&#125;;//普通购买订单var order = function (orderType, pay, stock)&#123; if (stock&gt;0) &#123; console.log('普通购买,没有优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125;&#125;;var Chain=function (fn)&#123; this.fn=fn; this.successor=null;&#125;;Chain.prototype.setNextSuccessor=function (successor)&#123; return this.successor=successor;&#125;;Chain.prototype.passRequest=function()&#123; var ret= this.fn.apply(this,arguments); if(ret==='nextSuccessor')&#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor,arguments); &#125; return ret;&#125;;var chainOrder500=new Chain(order500);var chainOrder200=new Chain(order200);var chainOrderNormal=new Chain(order);chainOrder500.setNextSuccessor(chainOrder200);chainOrder200.setNextSuccessor(chainOrderNormal);chainOrder500.passRequest(1, true, 500); // 500定金预购,得到100元优惠券chainOrder500.passRequest(2, true, 500); // 200定金预购,得到50元优惠券chainOrder500.passRequest(1, false, 0); // 手机库存不足 加入某天网站添加了300元定金购买的职责，我只需要添加特定的节点就可以了：12345678//300元订单var order300=function ()&#123;&#125;;var chainOrder300=new Chain(order300());chainOrder500.setNextSuccessor(chainOrder300);chainOrder300.setNextSuccessor(chainOrder200); 这样的话只需要编写简单的功能函数，改变职责链中的相关节点的顺序即可。 异步职责链上面的职责链代码中，每个节点函数同步返回一个特定的值nextSuccessor，来表示是否把请求传递给下一个节点。而现实开发中会遇到一些异步的问题，比如在一个节点中发起一个ajax异步请求，异步请求的结果才能决定是否继续在职责链中passRequest。 可以给Chain类添加一个原型方法Chain.prototype.next，表示手动传递请求给职责链中的下一个节点：12345678910111213141516171819202122232425262728Chain.prototype.next=function()&#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor,arguments);&#125;;//异步职责链的例子var fn1=new Chain(function ()&#123; console.log(1); return 'nextSuccessor';&#125;);var fn2=new Chain(function ()&#123; console.log(2); var self=this; setTimeout(function ()&#123; self.next(); &#125;,1000);&#125;);var fn3=new Chain(function ()&#123; console.log(3);&#125;);fn1.setNextSuccessor(fn2).setNextSuccessor(fn3);fn1.passRequest(); 职责链模式的优缺点：优点： 职责链最大的优点就是解耦了请求发送者和N个接收者之间的复杂关系。 职责链可以手动指定起始节点，请求并不是非得从链中的第一个节点开始传递。 缺点： 不能保证某个请求一定会被链中的节点处理，这种情况可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。 使程序中多了很多节点对象，可能再一次请求的过程中，大部分的节点并没有起到实质性的作用。他们的作用仅仅是让请求传递下去，从性能当面考虑，要避免过长的职责链到来的性能损耗。使用AOP（面向切面编程）来快速的创建职责链AOP的具体概念可以参考装饰者模式1234567891011121314151617Function.prototype.after = function (fn) &#123; var self = this; return function () &#123; var ret = self.apply(this, arguments); if (ret === 'nextSuccessor') &#123; return fn.apply(this, arguments); &#125; return ret; &#125;&#125;;var orderAop = order500.after(order200).after(order);orderAop(1, true, 500); // 500定金预购,得到100元优惠券orderAop(1, false, 500); // 普通购买,没有优惠券 AOP实现职责链简单又巧妙，但这种把函数叠在一起的方式，同时也叠加了函数的作用域，如果链条太长的话，也会对性能造成太大的影响。 总结职责链模式最大的优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之前的强联系。 在JavaScript开发中，职责链模式是最容易被忽视的模式之一。但是只要运用得当，职责链模式可以很好的帮助我们管理代码，降低发起请求的对象和处理请求的对象之间的耦合性。且职责链中节点的数量和数序是可以自由变化的。可以在运行时决定链中包含哪些节点。 无论是作用域链，原型链，还是DOM节点中的事件冒泡，我们都能从中找到职责链模式的影子。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://github.com/QiqiM/tags/行为型模式/"}]},{"title":"装饰者模式","date":"2020-07-08T07:00:01.000Z","path":"2020/07/08/设计模式/装饰者模式/","text":"装饰者模式的定义 装饰者模式是指动态的将功能附加到对象上。在对象功能扩展上更为方便，是继承一种替代方案 优点：装饰类和被装饰类都只关心自身的核心业务，实现了解耦；方便动态的扩展功能，且提供了比继承更多的灵活性 缺点：多层装饰比较复杂；常常会引入许多小对象，看起来比较相似，实际上功能大相径庭。使得应用程序架构边得复杂 传统语言的装饰者模式1234567891011121314151617181920212223242526//模拟传统语言的装饰者//原始的飞机类var Plan = function () &#123;&#125;;Plan.prototype.fire = function () &#123; console.log('发射普通子弹');&#125;;//装饰类var MissileDecorator = function (plan) &#123; this.plan = plan;&#125;MissileDecorator.prototype.fire = function () &#123; this.plan.fire(); console.log('发射导弹!');&#125;;var plan = new Plan();plan = new MissileDecorator(plan);plan.fire();// 发射普通子弹// 发射导弹! JavaScript中的装饰者模式 装饰者模式将一个对象嵌入到另一个对象之中，实际上相当于这个对象被另一个对像包装起来，形成一条包装链。请求随着这条包装链依次传递到所有的对象，每个对象都有处理这条请求的机会。 123456789101112131415161718var Plan1 = &#123; fire: function () &#123; console.log('发射普通的子弹'); &#125;&#125;;var missileDecorator= function () &#123; console.log('发射导弹!');&#125;;var fire = Plan1.fire;Plan1.fire=function () &#123; fire(); missileDecorator();&#125;;Plan1.fire(); 函数功能扩展 在JavaScript中，很容易给对象扩展属性与方法但是却不容易给函数扩展额外功能，除非改函数源码但是改写函数违反了开放-封闭原则 12345678var foo = function()&#123; console.log(1);&#125;//改为var foo = function()&#123; console.log(1); console.log(2);//增&#125; 一个常用的方法就是缓存函数引用，改写函数123456789101112var foo = function()&#123; console.log(1);&#125;//改为var foo = function()&#123; console.log(1);&#125;var _foo = foo;foo = function()&#123; _foo(); console.log(2);&#125; 但是这样写还是存在问题要维护额外的中间变量（_foo），如果装饰链过长，中间变量就会越来越多可能会存在this被劫持问题,关于this劫持问题，看下面的例子：123456var getId = document.getElementById;document.getElementById = function(ID)&#123; console.log(1); return getId(ID);&#125;document.getElementById('demo'); 因为使用 document.getElementById 的时候内部有this引用，而这个this期望指向的是document但是 getId 在获取了 document.getElementById引用后this就指向了window，导致抛出错误。为了让this正确指向document我们可以做出修改:123456var getId = document.getElementById;document.getElementById = function(ID)&#123; console.log(1); return getId.call(document, ID);&#125;document.getElementById('demo'); AOP装饰函数 AOP（Aspect Oriented Programming） 面向切面编程；把一些和核心业务逻辑无关的功能抽离出来，再通过动态织入的方式掺入业务逻辑模块。 与业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等等好处也很明显，保证了核心业务模块的纯净与高内聚性而且其他的功能模块也可以很好的复用。首先，我们要实现两个函数一个用来前置装饰，一个用来后置装饰: 直接在Function上做修改，会污染原型 1234567891011121314151617181920212223242526272829Function.prototype.before = function(beforeFunc)&#123; //保存旧函数的引用 var self = this; //返回包含旧函数和新函数的“代理”函数 return function()&#123; //执行新函数,且保证this不被劫持,新函数接受的参数 beforeFunc.apply(this, arguments); // 也会被原封不动的传入旧函数,新函数在旧函数之前执行 return self.apply(this, arguments); &#125;&#125;Function.prototype.after = function(afterFunc)&#123; var self = this; return function()&#123; var ret = self.apply(this, arguments); afterFunc.apply(this, arguments); return ret; &#125;&#125;function funcPro() &#123; console.log('test') &#125;funcPro = funcPro.before(function () &#123; console.log(\"before\");&#125;)funcPro();// before// test 不污染原型的做法 123456789101112131415var before=function (fn, before) &#123; return function () &#123; before.apply(this,arguments); return fn.apply(this,arguments); &#125;;&#125;;function func1()&#123;console.log('1')&#125;function func2() &#123;console.log('2')&#125;var a=before(func1,func2);a(); // 1// 2 es7装饰器实现12345678910111213141516171819202122function autopilotDecorator(target, key, descriptor) &#123; const method = descriptor.value; descriptor.value = () =&gt; &#123; method.apply(target); console.log('启动自动驾驶模式'); &#125; return descriptor;&#125;class Car &#123; @autopilotDecorator drive() &#123; console.log('乞丐版'); &#125;&#125;let car = new Car();car.drive(); //乞丐版//启动自动驾驶模式 decorator的实现依赖于ES5的Object.defineProperty方法。defineProperty所做的事情是为一个对象增加新的属性，或者更改某个已存在的属性。调用方式是Object.defineProperty(obj, prop, descriptor)。 123456789101112131415161718192021var o = &#123;&#125;; // 创建一个新对象// 在对象中添加一个属性Object.defineProperty(o, \"name\", &#123; value : \"Dickens\", writable : true, enumerable : true, configurable : true&#125;);// 在对象中添加一个方法Object.defineProperty(o, \"sayHello\", &#123; value : function() &#123; console.log('Hello, my name is: ', this.name) &#125;, writable : true, enumerable : true, configurable : true&#125;);o.sayHello() //Hello, my name is: Dickens 装饰者模式和代理模式的区别： 代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个代替者。本体定义了关键功能，而代理提供了或者拒绝对他的访问，或者是在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态的加入某些行为。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://github.com/QiqiM/tags/结构型模式/"}]},{"title":"命令模式","date":"2020-07-08T03:18:01.000Z","path":"2020/07/08/设计模式/命令模式/","text":"1.命令模式的定义 命令模式的目标是将方法的调用，请求或者操作封装到一个单独的对象中，给我们酌情执行同时参数化和传递方法调用的能力 2.使用场合 有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。 代码实现 es6实现 123456789101112131415161718192021222324252627282930313233class carManager&#123;// request informationrequestInfo(model, id) &#123;console.log(\"The information for \" + model + \" with ID \" + id + \" is foobar\");&#125;// purchase the carbuyVehicle(model, id) &#123;console.log(\"You have successfully purchased Item \" + id + \", a \" + model);&#125;// arrange a viewingarrangeViewing(model, id) &#123;console.log( \"You have successfully booked a viewing of \" + model + \" ( \" + id + \" ) \");&#125;execute(name)&#123;return this[name] &amp;&amp; this[name].apply(this, [].slice.call(arguments, 1));&#125;&#125;let car = new carManager();// 调用命令car.execute(\"arrangeViewing\", \"Ferrari\", \"14523\"); car.execute(\"requestInfo\", \"Ford Mondeo\", \"54323\"); car.execute(\"requestInfo\", \"Ford Escort\", \"34232\");car.execute(\"buyVehicle\", \"Ford Escort\", \"34232\");// You have successfully booked a viewing of Ferrari ( 14523 )// The information for Ford Mondeo with ID 54323 is foobar// The information for Ford Escort with ID 34232 is foobar// You have successfully purchased Item 34232, a Ford Escort 回调函数版 123456789101112131415161718192021222324252627282930313233343536373839404142let invokeCallback = function (cb) &#123; if (!!cb &amp;&amp; typeof cb === 'function') &#123; cb.apply(null, Array.prototype.slice.call(arguments, 1)); &#125; else &#123; //logger.error('invokeCallback invalid cb!!! stack:%j', (new Error()).stack); &#125;&#125;;class carManager &#123; // request information requestInfo(model, id, cb) &#123; invokeCallback(cb, null, &#123; code: 1, info: &#123; model, id &#125; &#125;); &#125; // purchase the car buyVehicle(model, id, cb) &#123; invokeCallback(cb, null, &#123; code: 1, info: &#123; model, id &#125; &#125;); &#125; // arrange a viewing arrangeViewing(model, id, cb) &#123; invokeCallback(cb, null, &#123; code: 1, info: &#123; model, id &#125; &#125;); &#125; execute(name) &#123; return this[name] &amp;&amp; this[name].apply(this, [].slice.call(arguments, 1)); &#125;&#125;// 回调函数版let cbfun = function (err, res) &#123; if (res.code !== 0) &#123; console.log(res.info) &#125;&#125;let car = new carManager();// 调用命令car.execute(\"arrangeViewing\", \"Ferrari\", \"14523\", cbfun);car.execute(\"requestInfo\", \"Ford Mondeo\", \"54323\", cbfun);car.execute(\"requestInfo\", \"Ford Escort\", \"34232\", cbfun);car.execute(\"buyVehicle\", \"Ford Escort\", \"34232\", cbfun);","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://github.com/QiqiM/tags/行为型模式/"}]},{"title":"观察者模式","date":"2020-07-08T03:18:01.000Z","path":"2020/07/08/设计模式/观察者模式/","text":"#### 1.观察者模式的定义 在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖他的对象都会收到通知，并自动更新 2.使用场合 当一个对象改变的时候，需要同时改变其他对象，并且它不知道具体有多少对象需要改变的时候，就需要考虑使用观察者模式 代码实现 发布订阅 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//通用代码 (极简主义写法)let observer = &#123; //订阅 addSubscriber: function (callback) &#123; this.subscribers[this.subscribers.length] = callback; &#125;, //退订 removeSubscriber: function (callback) &#123; for (let i = 0; i &lt; this.subscribers.length; i++) &#123; if (this.subscribers[i] === callback) &#123; delete (this.subscribers[i]); &#125; &#125; &#125;, //发布 publish: function (what) &#123; for (let i = 0; i &lt; this.subscribers.length; i++) &#123; if (typeof this.subscribers[i] === 'function') &#123; this.subscribers[i](what); &#125; &#125; &#125;, // 将对象o具有观察者功能 make: function (o) &#123; for (let i in this) &#123; o[i] = this[i]; o.subscribers = []; &#125; &#125;&#125;;let blogger = &#123; recommend: function (id) &#123; let msg = 'dudu 推荐了的帖子:' + id; this.publish(msg); &#125;&#125;;let user = &#123; vote: function (id) &#123; let msg = '有人投票了!ID=' + id; this.publish(msg); &#125;&#125;;observer.make(blogger);observer.make(user);let tom = &#123; read: function (what) &#123; console.log('Tom看到了如下信息：' + what) &#125;&#125;;let mm = &#123; show: function (what) &#123; console.log('mm看到了如下信息：' + what) &#125;&#125;;// 订阅blogger.addSubscriber(tom.read);blogger.addSubscriber(mm.show);blogger.recommend(123); //调用发布//退订blogger.removeSubscriber(mm.show);blogger.recommend(456); //调用发布//另外一个对象的订阅user.addSubscriber(mm.show);user.vote(789); //调用发布 观察者模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 主题 保存状态，状态变化之后触发所有观察者对象class Subject &#123; constructor() &#123; this.state = 0 this.observers = [] &#125; getState() &#123; return this.state &#125; setState(state) &#123; this.state = state this.notifyAllObservers() &#125; notifyAllObservers() &#123; this.observers.forEach(observer =&gt; &#123; observer.update() &#125;) &#125; attach(observer) &#123; this.observers.push(observer) &#125; remove(observer)&#123; const observerIndex = this.observers.findIndex(value =&gt; &#123; return value == observer; &#125;) observerIndex &gt;= 0 &amp;&amp; this.observers.splice(observerIndex, 1);&#125;;&#125;// 观察者class Observer &#123; constructor(name, subject) &#123; this.name = name this.subject = subject this.subject.attach(this) &#125; update() &#123; console.log(`$&#123;this.name&#125; update, state: $&#123;this.subject.getState()&#125;`) &#125; remove()&#123; this.subject.remove(this) &#125;&#125;// 测试let s = new Subject()let o1 = new Observer('o1', s)let o2 = new Observer('o2', s)s.setState(12)// o1 update, state: 12// o2 update, state: 12o2.remove()s.setState(11) // o1 update, state: 11","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://github.com/QiqiM/tags/行为型模式/"}]},{"title":"策略模式","date":"2020-07-07T05:28:01.000Z","path":"2020/07/07/设计模式/策略模式/","text":"#### 1.策略模式的定义 将不变的的部分和变化的部分分隔开时每个设计模式的主题，定义一系列的算法，将他们一个个封装起来，并使他们可以互相替换 2.策略模式的目的 将算法的使用与算法的实现分离开来 3.传统策略模式和js策略模式的实现 使用策略模式重构代码，可以消除程序中大片的条件分支语句。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以使用策略模式来封装他们 4.策略模式的优缺点 优点： 策略模式利用组合，委托和多态等技术思想，可以有效的避免多重条件选择语句 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得他们呢易于切换，易于理解，易于扩展。 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作 在策略模式中利用组合和委托让context拥有执行算法的能力，这也是继承的一种更轻便的替代方案。 缺点： 策略模式会在程序中添加许多的策略类和策略对象 要用策略模式，就必须要了解各个strategy和它们之间的不同点，这样才能选择一个合适的策略 5.函数多态性的描述 在函数作为一等对象的语言中，策略模式是隐形的，strategy就是值为函数的变量。 实际上在js这种将函数作为一等对象的语言里，策略模式已经融入到语言本身当中，我们经常使用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函数发出调用的消息时，不同的函数会返回不同的执行结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 传统语言的策略模式 ,使用策略模式来计算奖金 let performanceS = function()&#123;&#125;performanceS.prototype.calc = function(salary)&#123; return salary * 4&#125;let performanceA = function()&#123;&#125;performanceA.prototype.calc = function(salary)&#123; return salary * 3&#125;let performanceB = function()&#123;&#125;performanceB.prototype.calc = function(salary)&#123; return salary * 2&#125;// 定义奖金类let Bonus = function()&#123; this.salary = null; // 原始工资 this.strategy = null; // 计算奖金的策略&#125;Bonus.prototype.setSalary = function(sal)&#123; this.salary = sal; // 设置员工的原始工资&#125;Bonus.prototype.setStrategy = function(strategy)&#123; this.strategy = strategy // 设置对应的策略对象&#125;//获取奖金数额Bonus.prototype.getBonus = function()&#123; return this.strategy.calc(this.salary) // 把计算奖金的操作委托给对应的策略对象&#125;let bonus = new Bonus();bonus.setSalary(10000);bonus.setStrategy(new performanceS); // 设置策略对象console.log(bonus.getBonus()); // 40000bonus.setStrategy(new performanceA); console.log(bonus.getBonus()); // 30000 12345678910111213141516// js中的策略模式// 封装的策略方法let strategies = &#123; \"S\": (sal)=&gt; &#123;return sal * 4&#125;, \"A\": (sal)=&gt; &#123;return sal * 3&#125;, \"B\": (sal)=&gt; &#123;return sal * 2&#125;,&#125;// 具体计算方法let calcBonus = function(level,salary)&#123; return strategies[level](salary);&#125;console.log(calcBonus('S',1000)) // 4000console.log(calcBonus('A',4000)) // 12000","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://github.com/QiqiM/tags/行为型模式/"}]},{"title":"代理模式","date":"2020-07-06T13:30:01.000Z","path":"2020/07/06/设计模式/代理模式/","text":"1.代理模式的定义 为其他对象提供一种代理，用来控制这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用 使用场景 图片懒加载 防止用户频繁请求（一定时间内，多次请求按一次计算） 数据的缓存（比如业务中不好获取的数据，可以将该数据代理到app上，或者user身上，这样在整个程序中都可以很方便的访问） 优缺点 优点：代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介对象，这样可以起到保护对象的作用。代理对象也可以对目标对象调用之前进行其他操作。 缺点：增加了系统的复杂度 JavaScript开发中最常用的是虚拟代理和缓存代理。虚拟代理 根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象，比如浏览器的渲染的时候先显示问题，而图片可以慢慢显示（就是通过虚拟代理代替了真实的图片，此时虚拟代理保存了真实图片的路径和尺寸。用虚拟代理实现图片预加载代码实例： 123456789101112131415161718192021222324252627282930// 图片加载函数 var myImage = (function()&#123; var imgNode = document.createElement('img') document.body.appendChild(imgNode) return &#123; setSrc: function(src) &#123; imgNode.src = src &#125; &#125; &#125;)() // 引入代理对象 var proxyImage = (function()&#123; var img = new Image img.onload = function()&#123; // 图片加载完成，正式加载图片 myImage.setSrc( this.src ) &#125; return &#123; setSrc: function(src)&#123; // 图片未被载入时，加载一张提示图片 myImage.setSrc('file://c:/loading.png') img.src = src &#125; &#125; &#125;)() // 调用代理对象加载图片 proxyImage.setSrc( 'http://images/qq.jpg') proxyImage 间接地访问MyImage。proxyImage 控制了客户对MyImage 的访问，并且在此过程中加入一些额外的操作（真正的图片加载好之前，先把img 节点的src 设置为一张本地的loading 图片）。看完这段代码之后我们会立马思考一个问题，不使用代理模式我们照样可以实现图片的预加载功能，无非就是在MyImage的setSrc方法中加上图片加载完成监听以及加载本地提示图片这两部分代码，为什么要使用代理模式反而把实现变得复杂了？ 思考两个问题： 一、对于MyImage的setSrc函数来说职责过多，既要给img设置src，又要负责预加载图片，违反了面向对象设计原则中的单一职责原则； 二、如果后期我们考虑撤销图片预加载功能，就要去修改MyImage的setSrc方法，违反了开闭原则； 分析了上面两个问题后，代理模式恰好能规避掉这两个问题，此时就体现出了设计模式的优点。 缓存代理 缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。使用缓存代理实现运算结果缓存代码如下： 123456789101112131415161718192021222324252627282930var add = function()&#123; var sum = 0 for(var i = 0, l = arguments.length; i &lt; l; i++)&#123; sum += arguments[i] &#125; return sum&#125;var proxyAdd = (function()&#123; var cache = &#123;&#125; //缓存运算结果的缓存对象 return function()&#123; var args = Array.prototype.join.call(arguments)//把参数用逗号组成一个字符串作为“键” if(cache.hasOwnProperty(args))&#123;//等价 args in cache console.log('使用缓存结果') return cache[args]//直接使用缓存对象的“值” &#125; console.log('计算结果') return cache[args] = add.apply(this,arguments)//使用本体函数计算结果并加入缓存 &#125;&#125;)()console.log(proxyAdd(1,2,3,4,5))console.log(proxyAdd(1,2,3,4,5))console.log(proxyAdd(1,2,3,4,5))// 输出结果计算结果15使用缓存结果15使用缓存结果15 通过增加缓存代理的方式，add 函数可以继续专注于自身的职责——计算传入参数的和，缓存的功能是由代理对象实现的。 ES6中的代理Proxy ES6原生提供了Proxy构造函数，主要作用是在目标对象之前架设一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。其主要的思想还是设计模式，下面我们就来学习一下如何使用Proxy。 Proxy是一个构造函数，它可以接受两个参数：目标对象（target） 与句柄对象（handler） ，返回一个代理对象Proxy，主要用于从外部控制对对象内部的访问。 12const target = &#123;&#125;, handler = &#123;&#125;const proxy = new Proxy(target, handler) Proxy、target、handler这三者之间有什么关系呢？ Proxy的行为很简单：将Proxy的所有内部方法转发至target 。即调用Proxy的方法就会调用target上对应的方法。 handler是用来干嘛的？ handler的方法可以覆写任意代理的内部方法。 外界每次通过Proxy访问target 对象的属性时，就会经过 handler 对象，因此，我们可以通过重写handler对象中的一些方法来做一些拦截的操作。 举个栗子1234567891011121314let user = &#123; username: &apos;zhangsan&apos;, password: &apos;123456&apos;,&#125;var userProxy = new Proxy(user,&#123; get: function(target, property, receiver)&#123; console.log(`你访问了user的$&#123;property&#125;属性`) return target[prop] &#125;&#125;);console.log(userProxy.username)// 你访问了user的username属性 // zhangsan 如上面的代码，我们访问并输出了username属性，但是运行结果确又额外的输出了js我们在handler的get方法中预先输出的一句话，这就是拦截器的作用。 handler的内建方法 相信看了上面代码大家还有一个疑问，get方法是什么？get方法是handler对象的14个内建方法之一，我们可以通过重写这些内建方法来自定义拦截器的内容。handler对象拥有以下14个内建对象（我只举四个常用的，其他的请参考博客深度揭秘ES6代理Proxy）： 1handler.get(target, property, receiver) 方法用于拦截对象的读取属性操作 target，目标对象 property，被获取的属性名 receiver，Proxy或者继承Proxy的对象 1handler.set(target, property, value, receiver) 方法用于拦截设置属性值的操作 target，目标对象 property，被设置的属性名 value，被设置的新值 receiver，最初被调用的对象。通常是proxy本身，但handler的set方法也有可能在原型链上或以其他方式被间接地调用（因此不一定是proxy本身） 1handler.apply(target, thisArg, argumentsList) 方法用于拦截函数的调用 target，目标对象（函数） thisArg，被调用时的上下文对象 argumentsList，被调用时的参数列表 1handler.construct(target, argumentsList, newTarget) 用于来接new操作 target，目标对象 argumensList，构造器参数列表 newTarget，最初调用的构造函数 下面我们就来用ES6语法对虚拟代理例子进行重写 虚拟代理 123456789101112131415161718192021222324252627class myImage &#123; constructor(document) &#123; this.imgNode = document.createElement('img') document.body.appendChild(imgNode) &#125; setSrc() &#123; imgNode.src = src &#125;&#125;let myImageProxy = new Proxy(myImage, &#123; apply(target, ctx, arguments) &#123; var img = new Image img.onload = function()&#123; // 图片加载完成，正式加载图片 target.call(ctx, ...arguments) &#125; // 图片未被载入时，加载一张提示图片 target.call(ctx, 'file://c:/loading.png') img.src = arguments[0] &#125;&#125;)// 调用let myImg = new myImageProxy(document)myImg.setSrc('http://images/qq.jpg') 缓存代理 12345678910111213141516171819202122class Add &#123; constructor(arguments) &#123; var sum = 0; for(var i = 0, l = arguments.length; i &lt; l; i++)&#123; sum += arguments[i] &#125; return sum &#125;&#125;let AddProxy = new Proxy(Add, &#123; construct(target, arguments, newTarget) &#123; // newTarget最初的构造函数 let cache = target.cache // 从Add类中取出静态属性cache(缓存运算结果的缓存对象) var args = Array.prototype.join.call(arguments);//把参数用逗号组成一个字符串作为“键” if(cache.hasOwnProperty(args))&#123;//等价 args in cache console.log('使用缓存结果'); return cache[args];//直接使用缓存对象的“值” &#125; console.log('计算结果'); return cache[args] = newTarget(arguments);//使用本体函数计算结果并加入缓存 &#125;&#125;)","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://github.com/QiqiM/tags/结构型模式/"}]},{"title":"建造者模式","date":"2020-07-06T11:11:01.000Z","path":"2020/07/06/设计模式/建造者模式/","text":"#### 1.建造者模式的定义 建造者模式（bulider pattern）比较简单，将一个复杂的对象分解成多个简单的对象来进行构建，将复杂的构建层与表示层分离，使得相同的构建过程可以创建不同的表示的模式。 优点：封装性很好，对象的构建与表示分离；建造者模式很容易扩展，如果有新的需求，通过实现一个新的建造者类就可可以完成 缺点：使用范围受限，产品内部变化复杂会导致具体建造者过多 实现 建造者模式主要有4个部分：product产品类、Builder建造者类、Director指挥者类、客户。 主要的流程是： 客户提出需求。 指挥者根据用户需求，指挥建造者去完成需求的各个部分。 建造者完成相应的部分。 我们来看一下相应的代码： 产品类为一辆加工的空壳汽车。 代码实现1234567891011/** * 产品类：car 目前需要构建一辆车。 */class car &#123; constructor()&#123; this.name = ''; this.number = ''; this.wheel = ''; this.engine = ''; &#125;&#125; 12345678910111213141516171819202122232425/* * 建造者类，里面有专门负责各个部分的工人*/class carBuilder &#123; nameBuilder() &#123; this.name = '很厉害的车' &#125; numberBuilder() &#123; this.number = '88888888' &#125; wheelBuilder() &#123; this.wheel = '高级橡胶做的轮子' &#125; engineBuilder() &#123; this.engine = '很厉害的引擎' &#125; getCar() &#123; var Car = new car() Car.name = this.name; Car.number = this.number; Car.wheel = this.wheel; Car.engine = this.engine; return Car; &#125;&#125; 1234567891011121314/** * 指挥者类，指挥各个部分的工人工作 */class director &#123; constructor() &#123; &#125; action(builder) &#123; builder.nameBuilder(); builder.numberBuilder(); builder.wheelBuilder(); builder.engineBuilder(); &#125;&#125; 123456789/** * 使用方法 */var builder = new carBuilder();var director = new director();director.action(builder);var Car = builder.getCar();console.log(Car);","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://github.com/QiqiM/tags/创建型模式/"}]},{"title":"单例模式","date":"2020-07-06T08:48:01.000Z","path":"2020/07/06/设计模式/单例模式/","text":"#### 1.单例模式的定义 单例模式：限制类实例化次数只能一次，一个类只有一个实例，并提供一个访问它的全局访问点。 模式特点 类只有一个实例 全局可访问该实例 自行实例化（主动实例化） 可推迟初始化，即延迟执行（与静态类/对象的区别） 适用场景 “单例模式的特点，意图解决：维护一个全局实例对象。” 引用第三方库（多次引用只会使用一个库引用，如 jQuery） 弹窗（登录框，信息提升框） 购物车 (一个用户只有一个购物车) 全局态管理 store (Vuex / Redux) 项目中引入第三方库时，重复多次加载库文件时，全局只会实例化一个库对象，如 jQuery，lodash，moment ..., 其实它们的实现理念也是单例模式应用的一种：12345678// 引入代码库 libs(库别名）import libName from 'lib'if (window.libs != null) &#123; return window.libs; // 直接返回&#125; else &#123; window.libs = libName // 初始化&#125; 优点：适用于单一对象，只生成一个对象实例，避免频繁创建和销毁实例，减少内存占用。 缺点：不适用动态扩展对象，或需创建多个相似对象的场景 代码实现 使用闭包实现 12345678910var singleton = function( fn )&#123; var result; return function()&#123; return result || ( result = fn .apply( this, arguments ) ); &#125;&#125; var createMask = singleton( function()&#123; return document.body.appendChild( document.createElement('div') ); &#125;) TS实现 1234567891011121314151617181920212223242526272829303132// 饿汉式class Singleton1 &#123; // 1. 构造器私有化，外部不能new private constructor()&#123;&#125; // 2. 本类内部创建对象实例化 private static instance : Singleton1 = new Singleton1(); // 3. 提供一个公有的静态方法，返回实例对象 public static getInstance() : Singleton1 &#123; return this.instance; &#125;&#125;console.log(Singleton1.getInstance(), '11111');// 懒汉式class Singleton2 &#123; private constructor()&#123;&#125; private static instance: Singleton2 = null; public static getInstance() : Singleton2 &#123; if (this.instance === null) &#123; this.instance = new Singleton2(); &#125; return this.instance; &#125;&#125;console.log(Singleton2.getInstance(), '2222')","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://github.com/QiqiM/tags/创建型模式/"}]},{"title":"原型模式","date":"2020-07-06T08:48:01.000Z","path":"2020/07/06/设计模式/原型模式/","text":"#### 1.工厂模式的定义 原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。 优点：简化创建新对象的过程并提高效率，可动态获取对象运行时的状态；原始对象变化（增加或减少属性和方法），相应克隆对象会跟随着变化 缺点：对已有类修改时，需要修改源对象（违反了开放关闭原则） 代码实现12345678910111213141516171819var myCar = &#123; name: \"Ford Escort\", drive: function () &#123; console.log( \"Weeee. I'm driving!\" ); &#125;, panic: function () &#123; console.log( \"Wait. How do you stop this thing?\" ); &#125;&#125;;// Use Object.create to instantiate a new carvar yourCar = Object.create( myCar );// Now we can see that one is a prototype of the otherconsole.log( yourCar.name ); // Ford Escort Object.create也允许我们简单的继承先进的概念,比如对象能够直接继承自其它对象,这种不同的继承.我们早先也看到Object.create允许我们使用 供应的第二个参数来初始化对象属性。例如： 12345678910111213141516171819var vehicle = &#123; getModel: function () &#123; console.log( \"The model of this vehicle is..\" + this.model ); &#125;&#125;;var car = Object.create(vehicle, &#123; \"id\": &#123; value: MY_GLOBAL.nextId(), // writable:false, configurable:false by default enumerable: true &#125;, \"model\": &#123; value: \"Ford\", enumerable: true &#125;&#125;); es6自带的class extends实现 12345678910111213141516171819class Person &#123; constructor(name) &#123; this.name = name &#125; getName() &#123; return this.name &#125; &#125; class Student extends Person &#123; constructor(name) &#123; super(name) &#125; sayHello() &#123; console.log(`Hello， My name is $&#123;this.name&#125;`) &#125; &#125; let student = new Student(\"xiaoming\") student.sayHello() // Hello， My name is xiaoming 自定义实现 123456789101112131415161718192021222324var vehiclePrototype = &#123; init: function ( carModel ) &#123; this.model = carModel; &#125;, getModel: function () &#123; console.log( \"The model of this vehicle is..\" + this.model); &#125;&#125;;function vehicle( model ) &#123; function F() &#123;&#125;; F.prototype = vehiclePrototype; var f = new F(); f.init( model ); return f;&#125;var car = vehicle( \"Ford Escort\" );car.getModel(); //The model of this vehicle is..Ford Escort","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://github.com/QiqiM/tags/创建型模式/"}]},{"title":"什么是事件循环（Event Loop）","date":"2020-06-05T07:58:01.000Z","path":"2020/06/05/深入js系列/深入理解Node事件循环/","text":"什么是事件循环（Event loop）？WIKI定义： In computer science, the event loop, message dispatcher, message loop, message pump, or run loop is a programming construct that waits for and dispatches events or messages in a program. Event loop是一种程序结构，是实现异步的一种机制。Event loop可以简单理解为： 所有任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。系统把异步任务放到”任务队列”之中，然后主线程继续执行后续的任务。 一旦”执行栈”中的所有任务执行完毕，系统就会读取”任务队列”。如果这个时候，异步任务已经结束了等待状态，就会从”任务队列”进入执行栈，恢复执行。 主线程不断重复上面的第三步。 对JavaScript而言，Javascript引擎／虚拟机（如V8）之外，JavaScript的运行环境（runtime，如浏览器，node）维护了任务队列，每当JS执行异步操作时，运行环境把异步任务放入任务队列。当执行引擎的线程执行完毕（空闲）时，运行环境就会把任务队列里的（执行完的）任务（的数据和回调函数）交给引擎继续执行，这个过程是一个不断循环的过程，称为事件循环。 注意：JavaScript（引擎）是单线程的，Event loop并不属于JavaScript本身，但JavaScript的运行环境是多线程／多进程的，运行环境实现了Event loop。 另外，视频What the heck is the event loop anyway 站在前端的角度，用动画的形式描述了上述过程，可以便于理解。 解释Node.js的Event loop当Node.js启动时，它会初始化event loop，处理提供的代码（代码里可能会有异步API调用，timer，以及process.nextTick()），然后开始处理event loop。 下面是node启动的部分相关代码： 1234567891011121314151617181920// node.cc &#123; SealHandleScope seal(isolate); bool more; do &#123; v8_platform.PumpMessageLoop(isolate); more = uv_run(env.event_loop(), UV_RUN_ONCE); if (more == false) &#123; v8_platform.PumpMessageLoop(isolate); EmitBeforeExit(&amp;env); // Emit `beforeExit` if the loop became alive either after emitting // event, or after running some callbacks. more = uv_loop_alive(env.event_loop()); if (uv_run(env.event_loop(), UV_RUN_NOWAIT) != 0) more = true; &#125; &#125; while (more == true); &#125; Event Loop的执行顺序下面的示意图展示了一个简化的event loop的操作顺序： 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ （图来自Node.js API） 图中每个“盒子”都是event loop执行的一个阶段（phase）。 每个阶段都有一个FIFO的回调队列（queue）要执行。而每个阶段有自己的特殊之处，简单说，就是当event loop进入某个阶段后，会执行该阶段特定的（任意）操作，然后才会执行这个阶段的队列里的回调。当队列被执行完，或者执行的回调数量达到上限后，event loop会进入下个阶段。 Phases Overview 阶段总览 timers: 这个阶段执行setTimeout()和setInterval()设定的回调。 I/O callbacks: 执行被推迟到下一个iteration的 I/O 回调。 idle, prepare: 仅内部使用。 poll: 获取新的I/O事件；node会在适当条件下阻塞在这里。这个阶段执行几乎所有的回调，除了close回调，timer的回调，和setImmediate()的回调。 check: 执行setImmediate()设定的回调。 close callbacks: 执行比如socket.on(&#39;close&#39;, ...)的回调。 Phases in Detail 阶段详情timers一个timer指定一个下限时间而不是准确时间，在达到这个下限时间后执行回调。在指定时间过后，timers会尽可能早地执行回调，但系统调度或者其它回调的执行可能会延迟它们。 注意：技术上来说，poll 阶段控制 timers 什么时候执行。 注意：这个下限时间有个范围：[1, 2147483647]，如果设定的时间不在这个范围，将被设置为1。 I/O callbacks这个阶段执行一些系统操作的回调。比如TCP错误，如一个TCP socket在想要连接时收到ECONNREFUSED,类unix系统会等待以报告错误，这就会放到 I/O callbacks 阶段的队列执行。 pollpoll 阶段有两个主要功能： 执行下限时间已经达到的timers的回调，然后 处理 poll 队列里的事件。 当event loop进入 poll 阶段，并且 没有设定的timers（there are no timers scheduled），会发生下面两件事之一： 如果 poll 队列不空，event loop会遍历队列并同步执行回调，直到队列清空或执行的回调数到达系统上限； 如果 poll 队列为空，则发生以下两件事之一： 如果代码已经被setImmediate()设定了回调, event loop将结束 poll 阶段进入 check 阶段来执行 check 队列（里的回调）。 如果代码没有被setImmediate()设定回调，event loop将阻塞在该阶段等待回调被加入 poll 队列，并立即执行。 但是，当event loop进入 poll 阶段，并且 有设定的timers，一旦 poll 队列为空（poll 阶段空闲状态）： 11. event loop将检查timers,如果有1个或多个timers的下限时间已经到达，event loop将绕回 **timers** 阶段，并执行 **timer** 队列。 check这个阶段允许在 poll 阶段结束后立即执行回调。如果 poll 阶段空闲，并且有被setImmediate()设定的回调，event loop会转到 check 阶段而不是继续等待。 setImmediate()实际上是一个特殊的timer，跑在event loop中一个独立的阶段。它使用libuv的API来设定在 poll 阶段结束后立即执行回调。 通常上来讲，随着代码执行，event loop终将进入 poll 阶段，在这个阶段等待 incoming connection, request 等等。但是，只要有被setImmediate()设定了回调，一旦 poll 阶段空闲，那么程序将结束 poll 阶段并进入 check 阶段，而不是继续等待 poll 事件们 （poll events）。 close callbacks如果一个 socket 或 handle 被突然关掉（比如 socket.destroy()），close事件将在这个阶段被触发，否则将通过process.nextTick()触发。 event loop的一个例子讲述12345678910111213141516171819202122232425262728var fs = require(&apos;fs&apos;);function someAsyncOperation (callback) &#123; // 假设这个任务要消耗 95ms fs.readFile(&apos;/path/to/file&apos;, callback);&#125;var timeoutScheduled = Date.now();setTimeout(function () &#123; var delay = Date.now() - timeoutScheduled; console.log(delay + &quot;ms have passed since I was scheduled&quot;);&#125;, 100);// someAsyncOperation要消耗 95 ms 才能完成someAsyncOperation(function () &#123; var startCallback = Date.now(); // 消耗 10ms... while (Date.now() - startCallback &lt; 10) &#123; ; // do nothing &#125;&#125;); 当event loop进入 poll 阶段，它有个空队列（fs.readFile()尚未结束）。所以它会等待剩下的毫秒，直到最近的timer的下限时间到了。当它等了95ms，fs.readFile()首先结束了，然后它的回调被加到 poll的队列并执行——这个回调耗时10ms。之后由于没有其它回调在队列里，所以event loop会查看最近达到的timer的下限时间，然后回到 timers 阶段，执行timer的回调。 所以在示例里，回调被设定 和 回调执行间的间隔是105ms。 setImmediate() vs setTimeout()setImmediate() 和 setTimeout()是相似的，区别在于什么时候执行回调： setImmediate()被设计在 poll 阶段结束后立即执行回调； setTimeout()被设计在指定下限时间到达后执行回调。 下面看一个例子： 12345678// timeout_vs_immediate.jssetTimeout(function timeout () &#123; console.log(&apos;timeout&apos;);&#125;,0);setImmediate(function immediate () &#123; console.log(&apos;immediate&apos;);&#125;); 代码的输出结果是： 1234567$ node timeout_vs_immediate.jstimeoutimmediate$ node timeout_vs_immediate.jsimmediatetimeout 是的，你没有看错，输出结果是 不确定 的！ 从直觉上来说，setImmediate()的回调应该先执行，但为什么结果随机呢？ 再看一个例子： 1234567891011// timeout_vs_immediate.jsvar fs = require(&apos;fs&apos;)fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;timeout&apos;) &#125;, 0) setImmediate(() =&gt; &#123; console.log(&apos;immediate&apos;) &#125;)&#125;) 结果是： 1234567$ node timeout_vs_immediate.jsimmediatetimeout$ node timeout_vs_immediate.jsimmediatetimeout 很好，setImmediate在这里永远先执行！ 所以，结论是： 如果两者都在主模块（main module）调用，那么执行先后取决于进程性能，即随机。 如果两者都不在主模块调用（即在一个 IO circle 中调用），那么setImmediate的回调永远先执行。 那么又是为什么呢？ 看int uv_run(uv_loop_t* loop, uv_run_mode mode)源码（deps/uv/src/unix/core.c#332）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; r = uv__loop_alive(loop); if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; uv__update_time(loop); //// 1. timer 阶段 uv__run_timers(loop); //// 2. I/O callbacks 阶段 ran_pending = uv__run_pending(loop); //// 3. idle/prepare 阶段 uv__run_idle(loop); uv__run_prepare(loop); // 重新更新timeout，使得 uv__io_poll 有机会跳出 timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); //// 4. poll 阶段 uv__io_poll(loop, timeout); //// 5. check 阶段 uv__run_check(loop); //// 6. close 阶段 uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) &#123; uv__update_time(loop); // 7. UV_RUN_ONCE 模式下会再次检查timer uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; 上面的代码看起来很清晰，一一对应了我们的几个阶段。 首先进入timer阶段，如果我们的机器性能一般，那么进入timer阶段时，1毫秒可能已经过去了（setTimeout(fn, 0) 等价于setTimeout(fn, 1)），那么setTimeout的回调会首先执行。 如果没到一毫秒，那么我们可以知道，在check阶段，setImmediate的回调会先执行。 为什么fs.readFile回调里设置的，setImmediate始终先执行？因为fs.readFile的回调执行是在 poll 阶段，所以，接下来的 check 阶段会先执行 setImmediate 的回调。 我们可以注意到，UV_RUN_ONCE模式下，event loop会在开始和结束都去执行timer。 理解 process.nextTick()直到现在，我们才开始解释process.nextTick()。因为从技术上来说，它并不是event loop的一部分。相反的，process.nextTick()会把回调塞入nextTickQueue，nextTickQueue将在当前操作完成后处理，不管目前处于event loop的哪个阶段。 看看我们最初给的示意图，process.nextTick()不管在任何时候调用，都会在所处的这个阶段最后，在event loop进入下个阶段前，处理完所有nextTickQueue里的回调。 process.nextTick() vs setImmediate()两者看起来也类似，区别如下： process.nextTick()立即在本阶段执行回调； setImmediate()只能在 check 阶段执行回调。 文章转载于here","tags":[{"name":"JS","slug":"JS","permalink":"https://github.com/QiqiM/tags/JS/"},{"name":"深入js系列","slug":"深入js系列","permalink":"https://github.com/QiqiM/tags/深入js系列/"}]},{"title":"简单工厂模式","date":"2020-06-02T08:18:03.000Z","path":"2020/06/02/设计模式/简单工厂模式/","text":"概念也可以叫静态工厂模式，用一个工厂对象创建同一类对象类的实例。现实生活中，用户在平台还是分等级的，角色不同，权限也不同。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243class Role &#123; constructor(options) &#123; this.role = options.role; this.permissions = options.permissions; &#125; show() &#123; const str = `you are $&#123;this.role&#125;, permissions：$&#123;this.permissions.join(', ')&#125;`; console.log(str); &#125;&#125;class SampleFactory &#123; constructor(role) &#123; if(typeof this[role] !== 'function') &#123; throw new Error('param just can is admin or developer'); &#125; return this[role](); &#125; admin() &#123; return new Role(&#123; role: 'admin', permissions: ['write', 'read', 'add', 'create'] &#125;); &#125; developer() &#123; return new Role(&#123; role: 'admin', permissions: ['develop', 'push', 'ask'] &#125;); &#125;&#125;// 实例const xm = new SampleFactory('admin');xm.show();const xh = new SampleFactory('developer');xh.show();const xl = new SampleFactory('guest');xl.show(); 上例中，sampleFactory 就是一个简单工厂，2个实例对应不同的权限，调用工厂函数时，只需传递 admin 或 developer 就可获取对应的实例对象。 1.简单工厂函数适用场景 正确传参，就可以获取所需要的对象，无需知道内部实现细节； 内部逻辑（工厂函数）通过传入参数判断实例化还是使用哪些类； 创建对象数量少（稳定），对象的创建逻辑不复杂； 2.简单工厂函数不适用场景 当需要添加新的类时，就需要修改工厂方法，这违背了开放封闭原则（OCP, 对扩展开放、对源码修改封闭）。正所谓成也萧何败也萧何。函数 create 内包含了所有创建对象（构造函数）的判断逻辑代码，如果要增加新的构造函数还需要修改函数 create（判断逻辑代码），当可选参数 role 变得更多时，那函数 create 的判断逻辑代码就变得臃肿起来，难以维护。 不适用创建多类对象； 工厂方法模式将实际创建对象工作推迟到子类当中，核心类就成了抽象类。这样添加新的类时就无需修改工厂方法，只需要将子类注册进工厂方法的原型对象中即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class People &#123; // 基础人模板 name = \"基础人模板\"; constructor(props) &#123; this.name = props.name; &#125; &#125; class Programmer extends People &#123; // 程序员 programmingLanguage = \"JavaScript\"; constructor(props) &#123; super(props); this.programmingLanguage = props.programmingLanguage; &#125; &#125; class Driver extends People &#123; // 司机 driverLicense = \"无证老司机\"; constructor(props) &#123; super(props); this.driverLicense = props.driverLicense; &#125; &#125; class Chef extends People &#123; // 厨师 cookCard = \"无证\"; constructor(props) &#123; super(props); this.cookCard = props.cookCard; &#125; &#125; class PeopleFactory &#123; static createProgrammer(props) &#123; return new Programmer(props); &#125; static createDriver(props) &#123; return new Driver(props); &#125; static createChef(props) &#123; return new Chef(props); &#125; &#125; const unlicensedDriver = PeopleFactory.createDriver(&#123; name: \"老司机\", driverLicense: \"A1\" &#125;); console.log(unlicensedDriver); // Driver &#123; name: '老司机', driverLicense: 'A1' &#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://github.com/QiqiM/tags/创建型模式/"}]},{"title":"抽象工厂模式","date":"2020-06-02T07:48:01.000Z","path":"2020/06/02/设计模式/抽象工厂模式/","text":"概念抽象工厂模式(Abstract Factory)就是通过类的抽象使得业务适用于一个产品类簇的创建，而不负责某一类产品的实例。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 抽象工厂类class AbstractFactory &#123; static produce(params) &#123; this.factory; switch (params.factory) &#123; case \"NikeFactory\": this.factory = NikeFactory; break; case \"AdidasFactory\": this.factory = AdidasFactory; break; default: this.factory = NikeFactory; &#125; //返回之前，可以做一些逻辑处理 return this.factory.produce(params); &#125;&#125;//nike工厂class NikeFactory &#123; static produce(params) &#123; this.equipment; switch (params.factory) &#123; case \"NikeTShirts\": this.equipment = NikeTShirts; break; case \"NikeWinterJacket\": this.equipment = NikeWinterJacket; break; default: this.equipment = NikeTShirts; &#125; //返回之前，可以做nike工厂的逻辑处理 return new this.equipment(params); &#125;&#125;//adidas工厂class AdidasFactory &#123; static produce(params) &#123; this.equipment; switch (params.factory) &#123; case \"AdidasShoes\": this.equipment = AdidasShoes; break; case \"AdidasCap\": this.equipment = AdidasCap; break; default: this.equipment = AdidasCap; &#125; //返回之前，可以做adidas工厂的逻辑处理 return new this.equipment(params); &#125;&#125;//着装class Clothing &#123; constructor(params) &#123; this.factory = params.factory; this.type = params.type; this.size = params.size; this.price = params.price; &#125; publish() &#123; console.log('publish: ' + this.factory + ',' + this.type + ',size ' + this.size + ',price ' + this.price); &#125;&#125;//nike T 恤class NikeTShirts extends Clothing &#123;&#125;//nike 冲锋衣class NikeWinterJacket extends Clothing &#123;&#125;//adidas 鞋class AdidasShoes extends Clothing &#123;&#125;//adidas 帽子class AdidasCap extends Clothing &#123;&#125;// testlet nikeWinterJacket = AbstractFactory.produce(&#123; factory: 'NikeFactory', type: 'NikeWinterJacket', size: 'L', color: 'blue', price: 800,&#125;);console.log(nikeWinterJacket instanceof NikeWinterJacket); //truenikeWinterJacket.publish(); //publish: NikeFactory,NikeWinterJacket,size L,price 800 总结抽象类创建出的结果不是一个真实的对象实例，而是一个类簇，它指定了类的结构，这也就区别于简单工厂模式创建单一对象，抽象工厂模式创建多类对象。 通过抽象工厂，就可以创建某个类簇的产品，并且也可以通过instanceof来检查产品的类别，也具备该类簇所必备的方法。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/QiqiM/tags/设计模式/"},{"name":"js","slug":"js","permalink":"https://github.com/QiqiM/tags/js/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://github.com/QiqiM/tags/创建型模式/"}]},{"title":"win10安装Node版本管理器nvm","date":"2020-05-20T04:10:01.000Z","path":"2020/05/20/win10安装Node版本管理器nvm/","text":"使用nvm的原因开发公司项目和个人项目时，由于公司项目比较旧，Node版本比较低，但是自己做的项目安装的包，需要比较新的Node包，10以上的版本，所以就需要在同一台机器上安装多个版本的Node。经过搜索，决定使用nvm来做Node版本的管理。 安装前需要先将之前安装的Node版本完全删除 Windows设置 –&gt; 应用–&gt; 找到Node–&gt;点击卸载 重启电脑（或者从任务管理器中杀死所有Node相关的进程） 寻找以下文件夹并删除他们。根据您安装的版本，这些文件可能存在也可能不存在： C:\\Program Files (x86)\\Nodejs C:\\Program Files\\Nodejs C:\\Users{User}\\AppData\\Roaming\\npm（或%appdata%\\npm） C:\\Users{User}\\AppData\\Roaming\\npm-cache（或%appdata%\\npm-cache） 检查%PATH%环境变量，确保没有引用Nodejs和npm的存在 重启（重启大法解决90%问题） 下载安装nvm-window 20200520113014imagepng nvm安装位置，看自己决定，但是安装路径不能有空格，比如Program Files 20200520113215imagepng 安装的多版本Node放在哪里，也看个人喜好，可以修改 20200520113257imagepng 环境变量，安装好之后，环境变量会自动设置好 20200520113431imagepng 使用在你的nvm安装路径下打开cmd或者git bash,在其他路径下打开，会报错nvm： commond not found（重启！重启！重启！） nvm -v // 查看nvm版本，判断是否安装成功 20200520113838imagepng nvm ls available // 获取可获取的Node版本 20200520114039imagepng nvm install 12.14.1 // 安装指定版本的Node 20200520114149imagepng nvm use 12.14.1 // 使用指定版本Node 20200520114316imagepng nvm list // 列出本地已安装的Node版本 20200520114406imagepng nvm uninstall 10.15.3 // 卸载指定版本Node uninstall 常用命令 命令 功能 nvm -v 查看nvm版本，判断是否安装成功 nvm ls available 获取可获取的Node版本 nvm install 12.14.1 安装指定版本的Node nvm use 12.14.1 使用指定版本Node nvm uninstall 10.15.3 卸载指定版本Node 使用nvm引发的问题 全局安装的包找不到了，我之前有修改过我的全局包安装位置 12npm config set prefix &quot;F:\\nodejs\\node global&quot;npm config set cache &quot;F:\\nodejs\\node cache&quot; 因为卸载之前Node的时候，以前设置的Node环境变量也被清掉了，需要重新设置 system path 再增加一个环境变量 NODE_PATH 设置完之后，重开gitbash git_bash","tags":[{"name":"Node","slug":"Node","permalink":"https://github.com/QiqiM/tags/Node/"},{"name":"nvm","slug":"nvm","permalink":"https://github.com/QiqiM/tags/nvm/"}]},{"title":"蚂蚁金服单笔转账","date":"2020-05-19T04:00:01.000Z","path":"2020/05/19/蚂蚁金服单笔转账/","text":"单笔转账签约首先单笔转账这个功能需要和支付宝签约才可以使用，而且是注册商户90天以上的商家才可以申请签约，另外这个接口是资金累类接口，需要公钥证书加密，如果你查到的文档或者仓库使用的RSA加密的，可以不用看了，纯属浪费时间。如何申请公钥证书，可以参考支付宝的公钥证书加签文档 以下内容参照我 github的alipay仓库 查看先使用java工具生成支付宝根证书alipay_root_cert_sn和应用证书app_cert_sn,资金类接口这两个参数必传安装node sdk npm i alipay-sdk –save 参照示例Node/Alipay/index调用单笔转账接口注意事项 app_auth_token不是必传参数，可以不获取 签名加密的密钥不是RSA密钥，而是在CSR文件夹下，你使用支付宝工具生成的域名私钥 使用version3.0.8版本的包，需要加签一个参数 sdkVersion: &#39;alipay-sdk-nodejs-3.0.8&#39; 我的所有密钥数据都TEST，需要自行去支付宝申请证书验证","tags":[{"name":"蚂蚁金服","slug":"蚂蚁金服","permalink":"https://github.com/QiqiM/tags/蚂蚁金服/"},{"name":"支付对接","slug":"支付对接","permalink":"https://github.com/QiqiM/tags/支付对接/"}]},{"title":"CSRF攻击是什么？如何防范？","date":"2020-05-13T04:00:01.000Z","path":"2020/05/13/CSRF攻击是什么？如何防范？/","text":"1、CSRF攻击是什么？如何防范？ CSRF(Cross-site request forgery), 中文名称：跨站请求伪造。攻击者盗用了你的身份，以你的名义发送恶意请求。 CSRF能做的事情包括：以你的名义发送邮件，发消息，盗取你的账号，在受害者不知情的情况下，以受害者名义伪造请求发送给受攻击站点，从而在受害者并未授权的情况下执行受害者权限下的各种操作。 2、CSRF攻击的原理 正常网站A,存在CSRF漏洞;恶意网站B含有攻击性代码，用来对网站A进行攻击。 正常网站A，有两个用户user01(受害者)和user02(攻击者)。 user02(攻击者)清楚的了解网站A,并创建了具有攻击性的网站B(钓鱼网站)。 user01(受害者)登录了网站A后，在自身的session未失效的情况下，访问了恶意网站B. 3、 CSRF攻击的过程 1.用户user01通过浏览器访问正常网站A,输入用户名和密码请求登录验证 2.登录验证通过后，网站A保存user01的session,并将对应的cookie返回给user01的浏览器。这样user01就可以在网站A执行自身权限下的各种请求(操作)，比如取钱，发表文章，发表评论等 3.user01在未退出网站A的时候，在同一浏览器，点击访问了恶意网站B(钓鱼网站)，此时user02拿到user01的认证信息或者登录状态 4.网站B是user02创建的，user02清楚的知道网站A的工作模式，网站B通过攻击性代码访问网站A（携带的是user01的cookie)，执行某些并非user01授意的操作。 5.网站A并不知道这个恶意请求是从网站B发出的，因此，就会根据user01在网站A中具备的相关权限，执行权限下的各种操作。这样，就在user01不知情的情况下，user02假冒了user01,执行了具备user01用户身份才可以执行的操作 4、CSRF攻击实例假设，现在有一个受害者Bob，在网站http://bank.expample/有一大笔存款。Bob通过银行的网站发送请求http://bank.example/withdraw?account=Bob&amp;amount=100000&amp;to=Bob2,Bob将100000的存款转账到Bob2的账户下，通常情况下，该请求发送到银行网站后，服务器会先验证该请求是否来自一个合法的session,该session的用户Bob已经成功登录黑客Hack自己在该银行也有自己的账户，他知道银行转账操作的URL。Hack可以自己发送一个请求给银行：http://bank.example/withdraw?account=Bob&amp;amount=100000&amp;to=Hack,但是这个请求来自Hack，并非Bob,他不能通过安全验证，因此该请求不会起作用。这时，Hack香到使用CSRF的攻击方式，他先自己做一个网站B,在网站B中放入如下代码：src=&quot;http://bank.example/withdraw?account=Bob&amp;amount=100000&amp;to=Hack&quot;，并通过广告等方式诱使Bob访问他的网站。当Bob访问网站B的时候，上述URL就会从Bob的浏览器发向银行，并且这个请求会附带Bob浏览器的cookie一起发现银行服务器。当然，大多数情况下，该请求会失败（session有有效时间），因为银行网站需要要求Bob的认证信息。但是如果Bob当时恰巧刚访问银行网站后不久，他的浏览器与银行网站的session尚未过期（比如Bob在一个窗口还未退出银行网站），而浏览器中的cookie就含有Bob的认证信息，银行网站的对应session数据还在。这时悲剧就发生了，这个URL会得到银行服务器的响应，钱将从Bob的账号转移到Hack的账号，而Bob并不知情。等事后Bob发现账户钱变少了，去银行查询流水，却发现是他自己转移账户的钱，没有任何被攻击的痕迹（我搞我自己？人类迷惑行为）在这个示例中，银行网站错误的认为，这个转账时Bob本人执行的 5、CSRF攻击的对象从以上的例子可知，CSRF攻击是黑客借助受害者的cookie伪造请求，骗取服务器的信任。黑客所能做的就是给服务器发送伪造请求，改变请求时的参数。所以我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务。则不需要进行CSRF的保护。比如银行系统中转账的请求会直接改变账户的金额，会遭到CSRF攻击，需要保护，而查询余额是对金额的读取操作，不会改变数据，无需保护 6、CSRF漏洞检测检测CSRF漏洞是一项比较繁琐的工作，最简单的一个方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。随着对CSRF漏洞研究的不断深入，出现了一些针对CSRF漏洞进行检测的工具，如CSRFTester,CSRE Request Builder等。 CSRFTester工具的测试原理大概是这样的，使用代理抓取我们在浏览器中访问过的所有的连接以及所有的表单等信息，通过在CSRFTester中修改相应的表单等信息，重新提交，相当于一次伪造客户端请求，如果修测试的请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击 7、防范CSRF攻击的几种策略防范原理：防范CSRF攻击，其实本质上就是要求网站能够识别出哪些请求是非正常用户主动发起的。这就要求我们在请求中嵌入一些额外的授权数据，让网站服务器能够区分出这些未授权的请求。比如在请求参数中加一个字段，这个字段的值从登录用户的Cookie或者页面中获取（这个值需要是随机的，无规律可循）。攻击者伪造请求的时候无法获取页面中与登录用户有关的一个随机值或者cookie中的内容的。因此就可以避免这种攻击 目前防御CSRF攻击主要有以下几种策略 验证HTTP Referer字段 使用验证码（关键页面加上验证码验证，这种方法对用户不友好，不推荐） 在请求地址中加入token并验证 在HTTP头中自定义属性并验证 验证HTTP Referer字段HTTP头中的Referer字段记录该请求的来源地址。比如访问http://bank.example/withdraw?account=Bob&amp;amount=100000&amp;to=Hack，用户必须先登录http://bank.example,然后通过该网站页面的转账按钮来触发转账事件。这时，该转账请求的Referer值就会是转账按钮所在页面的URL,通常以bank.example域名开头的地址。 而如果黑客要对银行网站实施CSRF攻击，他只能在自己的网站构造请求，当用户通过黑客的网站发送请求到银行网站时，该请求的Referer是指向黑客自己的网站。 因此要防御CSRF攻击，银行只需要对转账请求验证其Referer值，如果以bank.example开头的域名，则说明该请求是来自银行网站自己的请求，是合法的，如果Referer是其他网站的话，则有可能是黑客的CSRF攻击，拒绝该请求。 优点： 简单易行，只需要在最后给所有敏感的请求统一增加一个拦截器来检查Referer的值就可以。特别对于当前现有的系统，不需要改变当前系统已有代码，没有风险，简单便捷 缺点： 这种方法并非万无一失 。首先，Referer的值是由浏览器提供的，但是每个浏览器对不Referer的具体实现会有差别，并不能保证浏览器自身没有安全漏洞。验证Referer的值，把安全性都依赖于浏览器来保障，不安全。而已已有一些方法可以篡改Referer值。另外，用户会因为隐私问题，设置浏览器不允许发送Referer值,这样服务端的Referer验证就没有了意义 在请求地址中添加token并验证CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户的 cookie来通过安全验证。 要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 中。 可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有 token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的token 进行比对。 对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue 。 而对于 POST 请求，要在 form 表单加上： &lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;该方法也有一个缺点是难以保证 token 本身的安全。 因为即使是 POST 请求的 token，黑客的网站也同样可以通过 Referer 的值来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。 如果想保证 token 本身的安全，可以考虑使用动态 token，也就是每次请求都使用不同的动态 token。 在 HTTP 头中自定义属性并验证这种方法也是使用 token 进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到HTTP 头中自定义的属性里。 通过 XMLHttpRequest 对象，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。 通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 然而，这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 对页面局部的异步刷新。 并非所有的请求都适合用 Ajax 来发起，而且通过该类请求得到的页面不能被浏览器所记录，影响前进、后退、刷新、收藏等操作，给用户带来了不便。 另外，对于没有进行 CSRF 防护的旧系统来说，如果采用这种方法来进行防护，需要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，工作量无疑是巨大的","tags":[{"name":"web安全","slug":"web安全","permalink":"https://github.com/QiqiM/tags/web安全/"},{"name":"名词理解","slug":"名词理解","permalink":"https://github.com/QiqiM/tags/名词理解/"}]},{"title":"深入理解js原型链","date":"2020-04-26T13:58:01.000Z","path":"2020/04/26/深入js系列/深入理解js原型链/","text":"概念 每个函数对象（构造函数constructor）都有一个原型对象属性（prototype），实例对象没有，指向prototype {}对象，原型对象都包含一个指向构造函数的指针。实例对象包含一个指向原型对象的内部指针[[prototype]]，在浏览器和Node中实现为__proto__。一图胜千言，直接上图 原型链1 原型链2 原型链3--经典宝藏 在浏览器中看最后一张图的输出1234567891011121314151617console.log(mycat)/* -Cp1: \"\" constructor:f() __proto__: native code*/mycat.__proto__// &#123;Cp1: \"\", constructor: f(),__proto__: Object&#125;Cat.prototype// &#123;Cp1: \"\", constructor: f(),__proto__: Object&#125;console.log(mycat.__proto__ === Cat.prototype) // trueCat.prototype.constructor// f () &#123;&#125; ==&gt; 指向函数对象本身（构造函数） __proto__和prototype关系 12345mycat.__proto__ // 函数对象mycat.__proto__.__proto__ // Objec 函数对象mycat.__proto__.__proto__.__proto__ // null __proto__和prototype关系 1234567Object.__proto__ // Function.prototype Object.__proto__.__proto__ // 等价与 Function.prototype.__proto__ Object.__proto === Function.prototype Function.prototype.__proto__ === Object.prototype Object原型查看 Object原型查看","tags":[{"name":"JS","slug":"JS","permalink":"https://github.com/QiqiM/tags/JS/"},{"name":"深入js系列","slug":"深入js系列","permalink":"https://github.com/QiqiM/tags/深入js系列/"}]},{"title":"模拟实现js的call和apply","date":"2020-04-07T02:46:01.000Z","path":"2020/04/07/深入js系列/模拟实现js的call和apply/","text":"call方法 call() 方法在使用一个指定的this和若干个指定的参数值的前提下调用某个函数或方法。 call的使用123456789101112131415161718192021/* * call语法 * function.call(thisArg, arg1, arg2, ...)* thisArg 可选参数，在function函数运行时的this值。注意 this可能不是该方法看到的实际值：如果这个函数处于非严格模式，则指定* 为null或者undefined时会自动替换为指向全局对象，原始值会被包装* (数字，字符串，布尔值)的this会执行该原始值的自动包装对象* * arg1,arg2... 指定的参数列表*/function greet() &#123; let reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ') console.log(reply)&#125;let obj = &#123; animal: 'cats', sleepDuration: '12 and 16 huors'&#125;greet.call(obj); // cat typically sleep between 12 and 16 hours call方法的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Function.prototype.callFn = function(context)&#123; // 只有function类型才可以调用call方法 if(typeof this !== 'function')&#123; throw new TypeError('must be function') &#125; // 有context时，指定为context，没有指向全局对象，浏览器里为 // windows，node下需要修改为global context = context ? Object(context) : window // context = context ? Object(context) : global // 此时的this为调用callFn方法的函数的this context.fn = this; // 取出函数执行需要的参数 let args = [...arguments].slice(1) let r = context.fn(args) delete context.fn return r&#125;// testlet value = 2;let obj = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value); return &#123; value: this.value, name: name, age: age &#125;&#125;bar.callFn(null); // 2console.log(bar.callFn(obj, 'kevin', 18));// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; apply方法 call()方法的作用和 apply() 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。 12345678910111213141516171819202122/* func.apply(thisArg, [argsArray])参数thisArg必选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。argsArray可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。*/window.val = 'window'var obj = &#123; val: 'obj'&#125;function getVal(p1, p2) &#123; console.log(p1, p2) console.log(this.val)&#125;getVal('param1', 'param2') // param1,param2,windowgetVal.apply(obj, ['param1', 'param2']) // param1,param2,obj apply实现1234567891011121314151617181920212223242526272829Function.prototype.applyFn = function(context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; context = context || window // context = context || global // node环境下 context.fn = this let result if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result&#125; // test node环境测试global.val = 'window'var obj = &#123; val: 'obj'&#125;function getVal(p1, p2) &#123; console.log(p1, p2) console.log(this.val)&#125;getVal('param1', 'param2') getVal.apply(obj, ['param1', 'param2']) 参考文章: https://juejin.im/post/5c4592faf265da617265c60b#heading-2参考文章: https://segmentfault.com/a/1190000017206223参考文章: https://github.com/mqyqingfeng/Blog/issues/11","tags":[{"name":"JS","slug":"JS","permalink":"https://github.com/QiqiM/tags/JS/"},{"name":"深入js系列","slug":"深入js系列","permalink":"https://github.com/QiqiM/tags/深入js系列/"}]},{"title":"模拟实现js的new","date":"2020-03-15T09:01:01.000Z","path":"2020/03/15/深入js系列/模拟实现js的new/","text":"new是什么 一句话介绍new ：new运算符创建一个用户自定义的对象类型的实例，或者具有构造函数的内置对象类型之一。看下下面的代码来了解new操作符都做了什么事情 123456789101112131415161718// Class (constructor)function Person(name,age)&#123; this.name = name this.age = age this.habit = 'watch tv'&#125;// 每个函数都有prototype对象属性// 在类的原型上挂载属性和方法，挂载载原型上，每个实例都可以调用，并且不会每个实例都挂载相同的属性和方法Person.prototype.strLength = 60Person.prototype.sayName = function()&#123; console.log('I am '+ this.name)&#125;// 实例化对象const person = new Person(\"yato\", 50)person.sayName();console.log(person) 20200315154922imagepng 进一步理解new 从上面这个例子中，我们可以看到，实例person可以 访问到Person构造函数里的属性 访问到Person.prototype中的属性 接下来模拟实现一个类似new的newFake，使用方式如下123456789function Person(arguments)&#123; // ...&#125;// 使用newlet person = new Person(arguments)// 使用newFakelet person = newFake(Person,arguments) 初步实现1234567891011121314151617181920212223242526272829303132333435function newFake()&#123; let obj = Object.create(&#123;&#125;) let Constructor = [].shift.call(arguments) if(typeof Constructor !== 'function')&#123; throw 'newOperator function the first param must be a function'; &#125; // 将新建对象的[[prototype]]属性指向到构造函数的prototype属性 obj.__proto__ = Constructor.prototype // 修改this指向到obj Constructor.apply(obj, arguments) return obj&#125;function Person(name,age)&#123; this.name = name this.age = age this.habit = 'watch tv'&#125;// 每个函数都有prototype对象属性// 在类的原型上挂载属性和方法，挂载载原型上，每个实例都可以调用，并且不会每个实例都挂载相同的属性和方法Person.prototype.strLength = 60Person.prototype.sayName = function()&#123; console.log('I am '+ this.name)&#125;// 实例化对象const person = newFake(Person,\"yato\", 50)person.sayName();console.log(person) 返回值处理 如果构造函数有返回值的情况 12345678910111213141516function Person(name,age)&#123; this.strLength = 60 this.age = age return &#123; name: name, habit: 'game' &#125;&#125;let person = new Person('yato', 18)console.log(person.name) // yatoconsole.log(person.habit) // gameconsole.log(person.strength) // undefinedconsole.log(person.age) // undefined 在这个例子中，构造函数返回了一个对象，在实例person中只能访问返回对象中的属性，而且还要注意一点，这里我们是返回一个对象，假设我们只返回一个基本类型值呢，看下面的例子 12345678910111213function Person(name,age)&#123; this.strLength = 60 this.age = age return 'good job'&#125;let person = new Person('yato', 18)console.log(person.name) // undefinedconsole.log(person.habit) // undefinedconsole.log(person.strength) // 60console.log(person.age) // 18 结果和正常new实例，无返回值的时候表现是一样的！可以得出结论：new操作最后一步，需要判断一返回值是否是一个对象，如果是一个对象就返回这个对象，如果不是对象就返回我们new内部的实例对象 第二版的new实现1234567891011121314151617181920212223242526272829function newFake()&#123; let obj = Object.create(&#123;&#125;) let Constructor = [].shift.call(arguments) if(typeof Constructor !== 'function')&#123; throw 'newOperator function the first param must be a function'; &#125; // ES6 new.target 是指向构造函数 newFake.target = ctor; // 将新建对象的[[prototype]]属性指向到构造函数的prototype属性 obj.__proto__ = Constructor.prototype // 修改this指向到obj let ret = Constructor.apply(obj, arguments) // 判断返回值是否为对象 Object(包含Functoin, Array, Date, RegExg, Error)都会直接返回这些值。 // 这些类型中合并起来只有Object和Function两种类型 typeof null 也是'object'所以要不等于null，排除 // null let isObject = typeof ret === 'object' &amp;&amp; ret !== null; let isFunction = typeof ret === 'function'; if(isObject || isFunction)&#123; return ret; &#125; return obj&#125; 总结一下new做了什么 创建了一个全新的对象 这个对象会被执行实例[[prototype]]属性到Class的prototype对象属性的链接（原型链） 生成的新对象会成为构造函数的调用的this(修改this指向) 通过new创建的每个实例对象最终将被[[prototype]]链接到构造函数的prototype对象上 如果函数没有返回对象类型（包含Function,Array,Date,RegExg,Error）,那么new表达式中的函数会自动返回这个新的对象","tags":[{"name":"JS","slug":"JS","permalink":"https://github.com/QiqiM/tags/JS/"},{"name":"深入js系列","slug":"深入js系列","permalink":"https://github.com/QiqiM/tags/深入js系列/"}]},{"title":"模拟实现js的bind方法","date":"2020-02-26T13:58:01.000Z","path":"2020/02/26/深入js系列/模拟实现js的bind方法/","text":"123456var obj = &#123;&#125;;console.log(obj);console.log(typeof Function.prototype.bind); // functionconsole.log(typeof Function.prototype.bind()); // functionconsole.log(Function.prototype.bind.name); // bindconsole.log(Function.prototype.bind().name); // bound 20200229141250imagepng bind是什么 a. bind 是Function原型链中Function.prototype的一个函数，每个函数都可以调用它。 b. bind本身是一个函数名为bind的函数，返回值也是函数，函数名是bound。(console出来为 bound加上一个空格)。 1234567891011121314151617181920let obj = &#123; name: \"yato\"&#125;function original(a,b)&#123; console.log(this.name) console.log([a,b]) return false&#125;let bound = original.bind(obj, 1)let boundInvoke = bound(2) // 'yato', Array(2)[1,2]console.log(boundInvoke) // falseconsole.log(original.bind.name) // bindconsole.log(original.bind.length) // 1console.log(original.bind().length) // 2 返回original函数形参个数console.log(bound.name) // 'bound original'console.log((function()&#123;&#125;).bind().name) // 'bound 'console.log((function()&#123;&#125;).bind().length) // 0 20200301155455imagepng 进一步理解bind a. 调用bind的函数中的this指向bind()函数的第一个参数。 b. 函数bind()时传递的参数被bind接受处理，bind()完毕之后，程序调用返回的函数（bound）时，传递的参数也接收处理了，也就是在bind()内部合并处理了。 c. 并且bind()后的函数的name为bound+空格+调用bind的函数名。如果调用函数为匿名函数，则名字为bound+空格 d. bind后的返回值函数，执行后返回值时原函数（original）的返回值（上例中的false） e. bind函数的形参（即函数的length）是1。bind后返回的bound函数形参不定，根据绑定的函数原函数（original）形参个数决定。 根据上面的两个例子，模拟实现一个简单版的bindFn123456789101112131415161718192021222324252627282930313233Function.prototype.bindFn = function bindFake(thisArg)&#123; if(typeof this !== 'function')&#123; throw new TypeError(this + 'must be a function') &#125; // 存储函数本身 let self = this // 去除thisArg的其他参数，转成数组 let args = [].slice.call(arguments, 1) let bound = function()&#123; // bind 返回的函数，也就是bound，在程序中被调用时传递的参数转成数组 let boundArg = [].slice.call(arguments); // apply修改this指向，把两个函数的参数合并传给self函数，返回执行结果 return self.apply(thisArg, args.concat(boundArg)) &#125; return bound&#125;// Testlet obj = &#123; name: 'yato'&#125;function original(a, b)&#123; console.log(this.name) console.log([a,b])&#125;let bound = original.bindFn(obj, 1)bound(2); // 'yato', [1,2] 但是函数是可以使用new来实例化的。1234567891011121314let obj = &#123;name : 'yato'&#125;function original(a, b)&#123; console.log('this : ', this) console.log('typeof this : ', typeof this) this.name = b console.log('name: ', this.name) console.log('this: ', this) console.log([a,b])&#125;let bound = original.bind(obj, 1)let newBoundInvoke = new bound(2)console.log('newBoundInvoke: ', newBoundInvoke) 分析例子可以得出结论 a. 从例子中可以看出this指向了new bound()生成的对象 b. new bound() 的返回值是以original原函数构造器生成的新对象。original原函数的this指向的就是这个新对象。 c.简要剖析下new做了什么 创建一个全新的空对象 对这个对象指向原型链接（instance.__proto__ = Class.prototype ），其实Class.prototype就是constructor 生成的新对象会绑定到函数调用的this 通过new创建的每个对象最终被[[prototype]]链接这个函数的prototype上（参考2） 如果函数没有返回对象类型Object(包含Function, Array, Date, RegExg, Error),那么new表达式中的函数调用会自动返回这个新的对象 所以相当于在new调用时，bind的返回值函数bound内部要实现new的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 第二版 实现new调用Function.prototype.bindFn = function bindFake(thisArg)&#123; if(typeof this !== 'function')&#123; throw new TypeError(this + ' must be a function') &#125; // 存储调用bind的函数本身的引用 let self = this // 去除thisArg参数，其他转成数组 let args = [].slice.call(arguments, 1) let bound = function()&#123; let boundArgs = [].slice.call(arguments) let finalArgs = args.concat(boundArgs) // new 调用时，其实this instanceof bound 判断不是很准确。es6 // new.target就是解决这一问题的 if(this instanceof bound)&#123; // 这里是实现上文描述的 new 的第 1, 2, 4 步 // 1.创建一个全新的对象 // 2.并且执行[[Prototype]]链接 // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。 // self可能是ES6的箭头函数，没有prototype，所以就没必要再指向做prototype操作。 if(self.prototype)&#123; function Empty()&#123;&#125; Empty.prototype = self.prototype bound.prototype = new Empty() &#125; // 这里实现的时上文描述的第三步 // 3.生成的新对象会绑定到函数调用的this let result = self.apply(this, finalArgs); // 这里是实现上文描述的 new 的第 5 步 // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, // `Error`)， // 那么`new`表达式中的函数调用会自动返回这个新的对象。 let isObject = typeof result === 'object' &amp;&amp; result !== null let isFunction = typeof result === 'function' if(isObject || isFunction) return result return this &#125;else&#123; // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果 return self.apply(thisArg, finalArgs) &#125; &#125; return bound&#125;// Testlet obj = &#123;name : 'yato'&#125;function original(a, b)&#123; console.log('this : ', this) console.log('typeof this : ', typeof this) this.name = b console.log('name: ', this.name) console.log('this: ', this) console.log([a,b])&#125;let bound = original.bindFn(obj, 1)let newBoundInvoke = new bound(2)console.log('newBoundInvoke: ', newBoundInvoke) 总结 bind是Function原型链中Function.prototype的一个属性，它是一个函数，修改this指向，合并参数传递给原函数，返回值是一个新的函数。 bind返回的函数可以通过new调用，这是提供的this参数被忽略，指向了new生成的全新对象。bind()内部模拟实现了new操作符","tags":[{"name":"JS","slug":"JS","permalink":"https://github.com/QiqiM/tags/JS/"},{"name":"深入js系列","slug":"深入js系列","permalink":"https://github.com/QiqiM/tags/深入js系列/"}]},{"title":"C++实现双向链表","date":"2019-06-25T02:43:13.000Z","path":"2019/06/25/C++实现双向链表/","text":"双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。 C++实现双向链表双向链表头文件(LinkList.h)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223#pragma once#ifndef _LINK_LIST_H#define _LINK_LIST_H#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;struct DNode&#123; public: T value; DNode *prev; DNode *next; public: DNode() &#123;&#125; DNode(T t, DNode *prev, DNode *next) &#123; this-&gt;value = t; this-&gt;prev = prev; this-&gt;next = next; &#125;&#125;;template&lt;class T&gt;class DoubleLink &#123; public: DoubleLink(); ~DoubleLink(); int size(); int isEmpty(); T get(int index); T getFirst(); T getLast(); int insert(int index, T t); int insertFirst(T t); int appendLast(T t); int del(int index); int delFirst(); int delLast(); private: int count; DNode&lt;T&gt; *pHead; private: DNode&lt;T&gt; *getNode(int index);&#125;;template&lt;class T&gt;DoubleLink&lt;T&gt;::DoubleLink() : count(0)&#123; // 创建表头。注意：表头没有存储数据 pHead = new DNode&lt;T&gt;(); pHead-&gt;next = NULL;&#125;// 析构函数template&lt;class T&gt;DoubleLink&lt;T&gt;::~DoubleLink()&#123; // 删除所有结点 DNode&lt;T&gt;* pTemp; DNode&lt;T&gt;* pNode = pHead-&gt;next; while (pNode != pHead) &#123; pTemp = pNode; pNode = pNode-&gt;next; delete pTemp; &#125; // 删除表头 delete pHead; pHead = NULL;&#125;// 返回结点数目template&lt;class T&gt;int DoubleLink&lt;T&gt;::isEmpty()&#123; return count == 0;&#125;// 返回节点数目template &lt; class T&gt;int DoubleLink&lt;T&gt;::size()&#123; return count;&#125;// 获取index位置的结点template&lt;class T&gt;DNode&lt;T&gt;* DoubleLink&lt;T&gt;::getNode(int index)&#123; // 判断参数有效性 if (index &lt; 0 || index &gt;= count) &#123; cout &lt;&lt; \" getNode failed! the index is out of round\" &lt;&lt; endl; return NULL; &#125; // 正向查找， 查找优化，减少查找次数 if (index &lt;= count / 2) &#123; int i = 0; DNode&lt;T&gt;* pIndex = pHead-&gt;next; while (i++ &lt; index) &#123; pIndex = pIndex-&gt;next; &#125; return pIndex; &#125; // 反向查找 int j = 0; int rIndex = count - index - 1; DNode&lt;T&gt;* pRindex = pHead-&gt;prev; while (j++ &lt; rIndex) &#123; pRindex = pRindex-&gt;prev; &#125; return pRindex;&#125;// 获取第index位置的结点的值template&lt;class T&gt;T DoubleLink&lt;T&gt;::get(int index)&#123; return getNode(index)-&gt;value;&#125;// 获取第一个结点的值template&lt;class T&gt;T DoubleLink&lt;T&gt;::getLast()&#123; return getNode(count-1)-&gt;value;&#125;// 获取最后一个结点的值template&lt;class T&gt;T DoubleLink&lt;T&gt;::getFirst()&#123; return getNode(0)-&gt;value;&#125;// 将结点插入到第index位置之前template&lt;class T&gt;int DoubleLink&lt;T&gt;::insert(int index, T t)&#123; if (index == 0) return insertFirst(t); DNode&lt;T&gt;* pIndex = getNode(index); DNode&lt;T&gt;* pNode = new DNode&lt;T&gt;(t, pIndex-&gt;prev, pIndex); pIndex-&gt;prev-&gt;next = pNode; pIndex-&gt;prev = pNode; count++; return 0;&#125;// 将结点插入到第一个结点处template&lt;class T&gt;int DoubleLink&lt;T&gt;::insertFirst(T t)&#123; DNode&lt;T&gt;* pNode = new DNode&lt;T&gt;(t, pHead, pHead-&gt;next); // 构造函数时就已经指定结点的前驱和后继结点了 // 这里第一个结点的时候需要判断空指针 if (pHead-&gt;next == NULL) pHead-&gt;prev = pNode; else pHead-&gt;next-&gt;prev = pNode; pHead-&gt;next = pNode; count++; return 0;&#125;// 将结点追加到链表的末尾template&lt;class T&gt;int DoubleLink&lt;T&gt;::appendLast(T t)&#123; DNode&lt;T&gt;* pNode = new DNode&lt;T&gt;(t, pHead-&gt;prev, pHead); pHead-&gt;prev-&gt;next = pNode; pHead-&gt;prev = pNode; count++; return 0;&#125;// 删除index位置的结点template&lt;class T&gt;int DoubleLink&lt;T&gt;::del(int index)&#123; DNode&lt;T&gt;* pIndex = getNode(index); pIndex-&gt;next-&gt;prev = pIndex-&gt;prev; pIndex-&gt;prev-&gt;next = pIndex-&gt;next; delete pIndex; count--; return 0;&#125;// 删除第一个结点template&lt;class T&gt;int DoubleLink&lt;T&gt;::delFirst()&#123; return del(0);&#125;// 删除最后一个结点template&lt;class T&gt;int DoubleLink&lt;T&gt;::delLast()&#123; return del(count - 1);&#125; #endif // !_LINK_LIST_H 双向链表测试文件(LinkList.cpp)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include \"pch.h\"#include &lt;iostream&gt;#include &lt;string&gt;#include \"LinkList.h\"using namespace std;// 双向链表操作int数据void intTest()&#123; int intArr[4] = &#123; 10,20,30,40 &#125;; cout &lt;&lt; \"\\n -------------intTest------------\" &lt;&lt; endl; // 创建双向链表 DoubleLink&lt;int&gt;* pDlinkList = new DoubleLink&lt;int&gt;(); pDlinkList-&gt;insert(0, 20); pDlinkList-&gt;appendLast(10); pDlinkList-&gt;insertFirst(30); pDlinkList-&gt;insert(1, 40); pDlinkList-&gt;delFirst(); // 双向链表是否为空 cout &lt;&lt; \"isEmpty= \" &lt;&lt; pDlinkList-&gt;isEmpty() &lt;&lt; endl; // 双向链表的长度 cout &lt;&lt; \"size=\" &lt;&lt; pDlinkList-&gt;size() &lt;&lt; endl; // 打印双向链表的全部数据 int length = pDlinkList-&gt;size(); for (int i = 0; i &lt; length; i++) &#123; cout &lt;&lt; \"pDlinkList(\" &lt;&lt; i &lt;&lt; \")=\" &lt;&lt; pDlinkList-&gt;get(i) &lt;&lt; endl; &#125;&#125;void stringTest()&#123; string sArr[4] = &#123; \"ten\",\"tewnty\",\"thirty\",\"forty\" &#125;; cout &lt;&lt; \"\\n------------stringTest-----------\" &lt;&lt; endl; DoubleLink&lt;string&gt;* pDlinkList = new DoubleLink&lt;string&gt;(); pDlinkList-&gt;insert(0, sArr[1]); pDlinkList-&gt;appendLast(sArr[0]); pDlinkList-&gt;insertFirst(sArr[2]); // 双向链表是否为空 cout &lt;&lt; \"isEmpty()=\" &lt;&lt; pDlinkList-&gt;isEmpty() &lt;&lt; endl; // 双向链表的长度 cout &lt;&lt; \"size=\" &lt;&lt; pDlinkList-&gt;size() &lt;&lt; endl; // 打印双向链表的全部数据 int length = pDlinkList-&gt;size(); for (int i = 0; i &lt; length; i++) &#123; cout &lt;&lt; \"pDlinkList(\" &lt;&lt; i &lt;&lt; \")=\" &lt;&lt; pDlinkList-&gt;get(i) &lt;&lt; endl; &#125;&#125;struct stu&#123; int id; char name[20];&#125;;static stu stuArr[] = &#123; &#123;10,\"one\"&#125;, &#123;20,\"two\"&#125;, &#123;30,\"three\"&#125;, &#123;40,\"four\"&#125;&#125;;#define ARR_STU_SIZE ((sizeof(stuArr)) / (sizeof(stuArr[0])))void objectTest()&#123; cout &lt;&lt; \"\\n------------stringTest-----------\" &lt;&lt; endl; DoubleLink&lt;stu&gt;* pDlinkList = new DoubleLink&lt;stu&gt;(); pDlinkList-&gt;insert(0, stuArr[1]); pDlinkList-&gt;appendLast(stuArr[0]); pDlinkList-&gt;insertFirst(stuArr[2]); // 双向链表是否为空 cout &lt;&lt; \"isEmpty()=\" &lt;&lt; pDlinkList-&gt;isEmpty() &lt;&lt; endl; // 双向链表的长度 cout &lt;&lt; \"size=\" &lt;&lt; pDlinkList-&gt;size() &lt;&lt; endl; // 打印双向链表的全部数据 struct stu p; int length = pDlinkList-&gt;size(); for (int i = 0; i &lt; length; i++) &#123; p = pDlinkList-&gt;get(i); cout &lt;&lt; \"pDlinkList(\" &lt;&lt; i &lt;&lt; \")=[\" &lt;&lt; p.id &lt;&lt;\" ,\" &lt;&lt; p.name&lt;&lt;\"]\" &lt;&lt; endl; &#125;&#125;int main()&#123; intTest(); stringTest(); objectTest(); return 0;&#125; 此文实现参考,侵权必删，大佬的有一些错误，经过测试已经修改。","tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://github.com/QiqiM/tags/algorithm/"},{"name":"C++","slug":"C","permalink":"https://github.com/QiqiM/tags/C/"},{"name":"LinkList","slug":"LinkList","permalink":"https://github.com/QiqiM/tags/LinkList/"}]},{"title":"常见排序算法1-冒泡排序","date":"2019-06-12T02:37:10.000Z","path":"2019/06/12/常见排序算法1--冒泡排序/","text":"算法原理 冒泡排序(Bubble Sort，也叫泡沫排序或气泡排序)，是一种简单的排序算法。它重复的走访过要排序的数列，一次比较两个元素，如果他们的顺序错误，将元素位置对调。走访数列的工作是重复进行的，直到再没有需要交换的数据，该数列排序完成。 冒泡排序算法的流程如下： 比较相邻的元素。如果第一个元素大于第二个元素，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数 针对所有的元素重复以上的步骤，除了最后一个元素（到最后一个元素，已经排好序了） 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 实例分析以数组arr = [5,2,6,9,3]为例说明，加粗的数字表示每次循环要比较的两个数字： 第一次外循环 ( 5 2 6 9 3 ) ==&gt; ( 2 5 6 9 3 ) | 5 &gt; 2 交换位置 ( 2 5 6 9 3 ) ==&gt; ( 2 5 6 9 3 ) | 5 &lt; 6 位置不变 ( 2 5 6 9 3 ) ==&gt; ( 2 5 6 9 3 ) | 6 &lt; 9 位置不变 ( 2 5 6 9 3 ) ==&gt; ( 2 5 6 3 9 ) | 9 &gt; 3 交换位置 第二次外循环 ( 2 5 6 3 9 ) ==&gt; ( 2 5 6 3 9 ) | 2 &lt; 3 位置不变 ( 2 5 6 3 9 ) ==&gt; ( 2 5 6 3 9 ) | 5 &lt; 6 位置不变 ( 2 5 6 3 9 ) ==&gt; ( 2 5 3 6 9 ) | 6 &gt; 3 交换位置 第三次外循环 ( 2 5 3 6 9 ) ==&gt; ( 2 5 3 6 9 ) | 2 &lt; 5 位置不变 ( 2 5 3 6 9 ) ==&gt; ( 2 3 5 6 9 ) | 5 &gt; 3 交换位置 第四次外循环（观察一下，其实此时已经排完序了，但是程序并不知道，所以仍要进行后续循环，直到剩余的序列为1） ( 2 3 5 6 9 ) ==&gt; ( 2 3 5 6 9 ) | 2 &lt; 5 位置不变 javaScript实现123456789101112131415161718let testArr = [5,2,6,9,3];function bubbleSort1(arr)&#123; let i,j,temp,l = arr.length; for(i = l- 1; i &gt; 0;i--)&#123; for(j = 0; j &lt; i;j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;bubbleSort1(testArr);console.log(testArr); // [ 2, 3, 5, 6, 9 ] 观察上面冒泡排序的流程，不需要到最后一步，就排序完成了，后面的循环就浪费了，可以设置个flag来使它的效率更高一些：添加一个标记，如果一趟遍历中发生了变换，则标记为true,否则为false.如果一趟没有发生交换，说明排序已经完成。 冒泡排序优化12345678910111213141516171819202122function bubbleSort2(arr)&#123; let i,j,temp,l = arr.length; let flag = 0; // 初始化flag为0 for(i = l- 1; i &gt; 0;i--)&#123; for(j = 0; j &lt; i;j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = 1; // 若发生交换，则标记为1 &#125; &#125; if(flag === 0) break; // 若没有发生交换，则说明数列已经有序 &#125;&#125;bubbleSort2(testArr);console.log(testArr); // [ 2, 3, 5, 6, 9 ]","tags":[{"name":"algorithm, sort","slug":"algorithm-sort","permalink":"https://github.com/QiqiM/tags/algorithm-sort/"}]},{"title":"屈原《渔父》","date":"2018-12-19T10:37:10.000Z","path":"2018/12/19/屈原《渔父》/","text":"转载自阮一峰老师的个人blog，侵权必删！原文链接 译文（大巧若工） 一个理想主义者痛苦地来到江边。在那里，他遇到了一个现实主义者。 现实问：“你为什么如此憔悴？” 理想答：“这个世界容不下我。我坚持的东西，其他人都无所谓；他们热衷的东西，我没有办法强迫自己加入。” 现实笑道：“老兄何必这么迂腐呢，别人怎么样，你也怎么样，不就可以了吗？他们脏，你也跟着一起脏，又何妨？像你这样自我孤立，真是自讨苦吃，不值得啊。” 理想说：“那我要问你，刚洗完头的人愿不愿意戴脏帽子，刚洗完澡的人愿不愿意穿脏衣服？干净的身体怎么能够甘心沾上灰尘呢？与其同流合污，不如选择孤独。” 现实指着面前的江水说：“你看这滔滔江水，如果水是清的，我就用它来洗衣服，活得干干净净；如果水是脏的，我就用它洗脚。人应该要学会适应。” 至此，两人就不再说话了。 《渔父》 —屈原 屈原既放，游于江潭，行吟泽畔；颜色憔悴，形容枯槁。 渔父见而问之曰：“子非三闾大夫与？何故至于斯？” 屈原曰：“举世皆浊我独清，众人皆醉我独醒，是以见放。” 渔父曰：“圣人不凝滞于物，而能与世推移。世人皆浊，何不淈其泥而扬其波？众人皆醉，何不铺其糟而歠其醨？何故深思高举，自令放为？” 屈原曰：“吾闻之：新沐者必弹冠，新浴者必振衣，安能以身之察察，受物之汶汶者乎？宁赴湘流，葬身于江鱼之腹中，安能以皓皓之白，而蒙世俗之尘埃乎？” 渔父莞尔而笑，鼓枻而去。歌曰：“沧浪之水清兮，可以濯吾缨；沧浪之水浊兮，可以濯吾足。”遂去，不复与言。","tags":[{"name":"Article","slug":"Article","permalink":"https://github.com/QiqiM/tags/Article/"}]},{"title":"历史过程","date":"2018-12-19T10:26:41.000Z","path":"2018/12/19/历史过程/","text":"转载自阮一峰老师的个人blog,侵权必删！原文链接 小时候，政治课里经常说，事物发展有一个历史过程。当时只觉得是很普通的一句话，现在明白它的涵义了。 什么叫历史过程？就是无法避免的牺牲。 贵州某山区，漫山遍野的小冶炼作坊，青山绿水成了黑山污水。重金属离子渗入土地，癌症流行，儿童极易出现畸形和智力低下。但是无法关闭这些作坊，因为关了就没收入，所以当地人明知有毒也要干。近几年，有色金属价格暴涨，又不知有多少山河要被毁掉。可是没有办法，这叫历史过程。 小煤矿每年死这么多人，为什么降不下来？因为当地财政依赖采矿收入，政府根本下不了决心关；而矿工如果不去挖煤，就要沦落为流浪汉。这叫历史过程。 中华人民共和国建国后的发展，就是依靠强制低收入来实现国家资本积累。我们的父辈下乡、支内、进国有工厂，不就是用他们的一生为国家的原始积累做贡献嘛？他们的人生就这样被牺牲掉了。这叫历史过程。 一位英国历史学家说：“历史涉及的只是一个民族生活的极小部分。人民的大部分生活，过去和未来都不会有文字记载。” 历史过程无法避免，生命就这样无意义地牺牲和痛苦着。唯愿那些为历史做陪葬的人生不要被忘记。","tags":[{"name":"Article","slug":"Article","permalink":"https://github.com/QiqiM/tags/Article/"}]},{"title":"php array","date":"2018-12-15T09:32:01.000Z","path":"2018/12/15/php-array/","text":"1.php中如何循环二维数组在php中，采用foreach循环来对二维索引数组进行遍历,下面的例子演示如何将三个关联数组，通过公有的key,在例子中是gid;组合成一个关联数组。 a.初始化数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061$paylist = array( 0=&gt;array( 'gid'=&gt; 1, 'money'=&gt; '100' ), 1=&gt;array( 'gid'=&gt; 1, 'money'=&gt; '200' ), 2=&gt;array( 'gid'=&gt; 4, 'money'=&gt; '300' ), 3=&gt;array( 'gid'=&gt; 6, 'money'=&gt; '400' ), );$rolelist = array( 0=&gt;array( 'gid'=&gt; 1, 'name'=&gt; 'xx1' ), 1=&gt;array( 'gid'=&gt; 2, 'name'=&gt; 'xx2' ), 2=&gt;array( 'gid'=&gt; 4, 'name'=&gt; 'xx4' ), 3=&gt;array( 'gid'=&gt; 6, 'name'=&gt; 'xx6' ), );$serverlist = array( 0=&gt;array( 'gid'=&gt; 1, 'servername'=&gt; 's1' ), 1=&gt;array( 'gid'=&gt; 2, 'servername'=&gt; 's2' ), 2=&gt;array( 'gid'=&gt; 4, 'servername'=&gt; 's4' ), 3=&gt;array( 'gid'=&gt; 6, 'servername'=&gt; 's4' ), );$gsidarr = array(1,1,4,6);//去重排序$gsidarr = array_unique($gsidarr);$gsidarr = array_values($gsidarr); b.构造数据(将公有key提取出来作为key值索引)12345678910111213141516171819202122$roleresult = array();foreach($rolelist as $key =&gt; $value)&#123; $roleresult[$value['gid']] = $value;&#125;echo '&lt;/br&gt;----'.json_encode($roleresult).'&lt;/br&gt;';foreach($roleresult as $k=&gt;$v)&#123; echo $v['name'].'==&gt;'.$v['gid'].'--&lt;/br&gt;'; //打印一下构造之后的数据&#125;// 构造之后的数据roleresult//&#123;\"1\":&#123;\"gid\":1,\"name\":\"xx1\"&#125;,\"2\":&#123;\"gid\":2,\"name\":\"xx2\"&#125;,\"4\":&#123;\"gid\":4,\"name\":\"xx4\"&#125;,\"6\":&#123;\"gid\":6,\"name\":\"xx6\"&#125;&#125;$serresult = array();foreach($serverlist as $key =&gt; $value)&#123; $serresult[$value['gid']] = $value;&#125;echo '&lt;/br&gt;----'.json_encode($serresult).'&lt;/br&gt;';foreach($serresult as $k=&gt;$v)&#123; echo $v['servername'].'==&gt;'.$v['gid'].'--&lt;/br&gt;';&#125;// 构造之后的数据serverresult// &#123;\"1\":&#123;\"gid\":1,\"servername\":\"s1\"&#125;,\"2\":&#123;\"gid\":2,\"servername\":\"s2\"&#125;,\"4\":&#123;\"gid\":4,\"servername\":\"s4\"&#125;,\"6\":&#123;\"gid\":6,\"servername\":\"s4\"&#125;&#125; c.将构造好的数据组合起来(通过公有key来取roleresult和serverresult的value)1234567891011121314151617181920$ret = array();foreach($paylist as $v)&#123; $data = array( 'money'=&gt;$v['money'], 'gid'=&gt;$v['gid'], 'name'=&gt;$roleresult[$v['gid']]['name'], 'servername'=&gt;$serresult[$v['gid']]['servername'] ); array_push($ret,$data);&#125;//组装好之后的数据/* [&#123;\"money\":\"100\",\"gid\":1,\"name\":\"xx1\",\"servername\":\"s1\"&#125;,&#123;\"money\":\"200\", \"gid\":1,\"name\":\"xx1\",\"servername\":\"s1\"&#125;,&#123;\"money\":\"300\",\"gid\":4, \"name\":\"xx4\",\"servername\":\"s4\"&#125;,&#123;\"money\":\"400\",\"gid\":6,\"name\":\"xx6\", \"servername\":\"s4\"&#125;]*/echo '&lt;/br&gt;----'.json_encode($ret).'&lt;/br&gt;'; 2.最后附一个在线测试代码的网站在线测试网站","tags":[{"name":"php","slug":"php","permalink":"https://github.com/QiqiM/tags/php/"},{"name":"array","slug":"array","permalink":"https://github.com/QiqiM/tags/array/"}]},{"title":"Hello World","date":"2018-11-19T10:37:10.000Z","path":"2018/11/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Test","slug":"Test","permalink":"https://github.com/QiqiM/tags/Test/"},{"name":"hexo","slug":"hexo","permalink":"https://github.com/QiqiM/tags/hexo/"}]}]