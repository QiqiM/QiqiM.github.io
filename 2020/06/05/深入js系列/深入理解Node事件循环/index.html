<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>什么是事件循环（Event Loop） | yato | 苟有恒,何必三更起五更眠; 最无益,莫过一日曝十日寒</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JS,深入js系列">
    <meta name="description" content="什么是事件循环（Event loop）？WIKI定义：  In computer science, the event loop, message dispatcher, message loop, message pump, or run loop is a programming construct that waits for and dispatches events or message">
<meta name="keywords" content="JS,深入js系列">
<meta property="og:type" content="article">
<meta property="og:title" content="什么是事件循环（Event Loop）">
<meta property="og:url" content="https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/index.html">
<meta property="og:site_name" content="yato">
<meta property="og:description" content="什么是事件循环（Event loop）？WIKI定义：  In computer science, the event loop, message dispatcher, message loop, message pump, or run loop is a programming construct that waits for and dispatches events or message">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-08-09T05:24:32.368Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="什么是事件循环（Event Loop）">
<meta name="twitter:description" content="什么是事件循环（Event loop）？WIKI定义：  In computer science, the event loop, message dispatcher, message loop, message pump, or run loop is a programming construct that waits for and dispatches events or message">
    
        <link rel="alternate" type="application/atom+xml" title="yato" href="/QiqiM.github.io/atom.xml">
    
    <link rel="shortcut icon" href="/QiqiM.github.io/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/QiqiM.github.io/img/brand.jpg)">
      <div class="brand">
        <a href="/QiqiM.github.io/" class="avatar waves-effect waves-circle waves-light">
          <img src="/QiqiM.github.io/img/avatar1.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">yato</h5>
          <a href="mailto:2602231824@qq.com" title="2602231824@qq.com" class="mail">2602231824@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/QiqiM.github.io/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/QiqiM.github.io/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/QiqiM.github.io/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/QiqiM.github.io/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://qiqim.github.io/" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://space.bilibili.com/25621747/#/favlist" target="_blank" >
                <i class="icon icon-lg icon-bilibili"></i>
                Bilibili
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">什么是事件循环（Event Loop）</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">什么是事件循环（Event Loop）</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-06-05T07:58:01.000Z" itemprop="datePublished" class="page-time">
  2020-06-05
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/QiqiM.github.io/categories/JS/">JS</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#什么是事件循环（Event-loop）？"><span class="post-toc-number">1.</span> <span class="post-toc-text">什么是事件循环（Event loop）？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#解释Node-js的Event-loop"><span class="post-toc-number">2.</span> <span class="post-toc-text">解释Node.js的Event loop</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Event-Loop的执行顺序"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">Event Loop的执行顺序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Phases-Overview-阶段总览"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">Phases Overview 阶段总览</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Phases-in-Detail-阶段详情"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">Phases in Detail 阶段详情</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#timers"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">timers</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#I-O-callbacks"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">I/O callbacks</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#poll"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">poll</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#check"><span class="post-toc-number">2.3.4.</span> <span class="post-toc-text">check</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#close-callbacks"><span class="post-toc-number">2.3.5.</span> <span class="post-toc-text">close callbacks</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#event-loop的一个例子讲述"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">event loop的一个例子讲述</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#setImmediate-vs-setTimeout"><span class="post-toc-number">3.</span> <span class="post-toc-text">setImmediate() vs setTimeout()</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#理解-process-nextTick"><span class="post-toc-number">4.</span> <span class="post-toc-text">理解 process.nextTick()</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#process-nextTick-vs-setImmediate"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">process.nextTick() vs setImmediate()</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#文章转载于here"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">文章转载于here</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-深入js系列/深入理解Node事件循环"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">什么是事件循环（Event Loop）</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-06-05 15:58:01" datetime="2020-06-05T07:58:01.000Z"  itemprop="datePublished">2020-06-05</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/QiqiM.github.io/categories/JS/">JS</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="什么是事件循环（Event-loop）？"><a href="#什么是事件循环（Event-loop）？" class="headerlink" title="什么是事件循环（Event loop）？"></a>什么是事件循环（<code>Event loop</code>）？</h2><p>WIKI定义：</p>
<blockquote>
<p>In computer science, the <strong>event loop, message dispatcher, message loop, message pump, or run loop</strong> is a programming construct that waits for and dispatches events or messages in a program.</p>
</blockquote>
<p>Event loop是一种程序结构，是实现异步的一种机制。Event loop可以简单理解为：</p>
<ol>
<li>所有任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。系统把异步任务放到”任务队列”之中，然后主线程继续执行后续的任务。</li>
<li>一旦”执行栈”中的所有任务执行完毕，系统就会读取”任务队列”。如果这个时候，异步任务已经结束了等待状态，就会从”任务队列”进入执行栈，恢复执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<p>对JavaScript而言，Javascript引擎／虚拟机（如V8）之外，JavaScript的运行环境（runtime，如浏览器，node）维护了任务队列，每当JS执行异步操作时，运行环境把异步任务放入任务队列。当执行引擎的线程执行完毕（空闲）时，运行环境就会把任务队列里的（执行完的）任务（的数据和回调函数）交给引擎继续执行，这个过程是一个<strong>不断循环</strong>的过程，称为<strong>事件循环</strong>。</p>
<p><strong>注意：JavaScript（引擎）是单线程的，Event loop并不属于JavaScript本身，但JavaScript的运行环境是多线程／多进程的，运行环境实现了Event loop。</strong></p>
<p>另外，视频<a href="http://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html" target="_blank" rel="noopener">What the heck is the event loop anyway</a> 站在前端的角度，用动画的形式描述了上述过程，可以便于理解。</p>
<h2 id="解释Node-js的Event-loop"><a href="#解释Node-js的Event-loop" class="headerlink" title="解释Node.js的Event loop"></a>解释Node.js的Event loop</h2><p>当Node.js启动时，它会初始化event loop，处理提供的代码（代码里可能会有异步API调用，timer，以及<code>process.nextTick()</code>），然后开始处理event loop。</p>
<p>下面是node启动的部分相关代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// node.cc</span><br><span class="line">  &#123;</span><br><span class="line">    SealHandleScope seal(isolate);</span><br><span class="line">    bool more;</span><br><span class="line">    do &#123;</span><br><span class="line">      v8_platform.PumpMessageLoop(isolate);</span><br><span class="line">      more = uv_run(env.event_loop(), UV_RUN_ONCE);</span><br><span class="line"></span><br><span class="line">      if (more == false) &#123;</span><br><span class="line">        v8_platform.PumpMessageLoop(isolate);</span><br><span class="line">        EmitBeforeExit(&amp;env);</span><br><span class="line"></span><br><span class="line">        // Emit `beforeExit` if the loop became alive either after emitting</span><br><span class="line">        // event, or after running some callbacks.</span><br><span class="line">        more = uv_loop_alive(env.event_loop());</span><br><span class="line">        if (uv_run(env.event_loop(), UV_RUN_NOWAIT) != 0)</span><br><span class="line">          more = true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; while (more == true);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Event-Loop的执行顺序"><a href="#Event-Loop的执行顺序" class="headerlink" title="Event Loop的执行顺序"></a>Event Loop的执行顺序</h3><p>下面的示意图展示了一个简化的event loop的操作顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure>
<p>（图来自<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">Node.js API</a>）</p>
<p><em>图中每个“盒子”都是event loop执行的一个阶段（phase）。</em></p>
<p>每个阶段都有一个<strong>FIFO</strong>的回调队列（queue）要执行。而每个阶段有自己的特殊之处，简单说，就是当event loop进入某个阶段后，会执行该阶段特定的（任意）操作，然后才会执行这个阶段的队列里的回调。当队列被执行完，或者执行的回调数量达到上限后，event loop会进入下个阶段。</p>
<h3 id="Phases-Overview-阶段总览"><a href="#Phases-Overview-阶段总览" class="headerlink" title="Phases Overview 阶段总览"></a>Phases Overview 阶段总览</h3><ul>
<li><strong>timers:</strong> 这个阶段执行<code>setTimeout()</code>和<code>setInterval()</code>设定的回调。</li>
<li><strong>I/O callbacks:</strong> 执行被推迟到下一个iteration的 I/O 回调。</li>
<li><strong>idle, prepare:</strong> 仅内部使用。</li>
<li><strong>poll:</strong> 获取新的I/O事件；node会在适当条件下阻塞在这里。这个阶段执行几乎所有的回调，除了<code>close</code>回调，timer的回调，和<code>setImmediate()</code>的回调。</li>
<li><strong>check:</strong> 执行<code>setImmediate()</code>设定的回调。</li>
<li><strong>close callbacks:</strong> 执行比如<code>socket.on(&#39;close&#39;, ...)</code>的回调。</li>
</ul>
<h3 id="Phases-in-Detail-阶段详情"><a href="#Phases-in-Detail-阶段详情" class="headerlink" title="Phases in Detail 阶段详情"></a>Phases in Detail 阶段详情</h3><h4 id="timers"><a href="#timers" class="headerlink" title="timers"></a>timers</h4><p>一个timer指定一个下限时间而不是准确时间，在达到这个下限时间后执行回调。在指定时间过后，timers会尽可能早地执行回调，但系统调度或者其它回调的执行可能会延迟它们。</p>
<p>注意：技术上来说，<strong>poll</strong> 阶段控制 timers 什么时候执行。</p>
<p>注意：这个下限时间有个范围：<code>[1, 2147483647]</code>，如果设定的时间不在这个范围，将被设置为1。</p>
<h4 id="I-O-callbacks"><a href="#I-O-callbacks" class="headerlink" title="I/O callbacks"></a>I/O callbacks</h4><p>这个阶段执行一些系统操作的回调。比如TCP错误，如一个TCP socket在想要连接时收到<code>ECONNREFUSED</code>,<br>类unix系统会等待以报告错误，这就会放到 <strong>I/O callbacks</strong> 阶段的队列执行。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><strong>poll</strong> 阶段有两个主要功能：</p>
<ol>
<li>执行下限时间已经达到的timers的回调，然后</li>
<li>处理 <strong>poll</strong> 队列里的事件。</li>
</ol>
<p>当event loop进入 <strong>poll</strong> 阶段，并且 <em>没有设定的timers（there are no timers scheduled）</em>，会发生下面两件事之一：</p>
<ol>
<li>如果 <strong>poll</strong> 队列不空，event loop会遍历队列并同步执行回调，直到队列清空或执行的回调数到达系统上限；</li>
<li>如果 <strong>poll</strong> 队列为空，则发生以下两件事之一：<ol>
<li>如果代码已经被<code>setImmediate()</code>设定了回调, event loop将结束 <strong>poll</strong> 阶段进入 <strong>check</strong> 阶段来执行 <strong>check</strong> 队列（里的回调）。</li>
<li>如果代码没有被<code>setImmediate()</code>设定回调，event loop将阻塞在该阶段等待回调被加入 <strong>poll</strong> 队列，并立即执行。</li>
</ol>
</li>
</ol>
<p>但是，当event loop进入 <strong>poll</strong> 阶段，并且 <em>有设定的timers</em>，一旦 <strong>poll</strong> 队列为空（<strong>poll</strong> 阶段空闲状态）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. event loop将检查timers,如果有1个或多个timers的下限时间已经到达，event loop将绕回 **timers** 阶段，并执行 **timer** 队列。</span><br></pre></td></tr></table></figure>
<h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>这个阶段允许在 <strong>poll</strong> 阶段结束后立即执行回调。如果 <strong>poll</strong> 阶段空闲，并且有被<code>setImmediate()</code>设定的回调，event loop会转到 <strong>check</strong> 阶段而不是继续等待。</p>
<p><code>setImmediate()</code>实际上是一个特殊的timer，跑在event loop中一个独立的阶段。它使用<code>libuv</code>的API<br>来设定在 <strong>poll</strong> 阶段结束后立即执行回调。</p>
<p>通常上来讲，随着代码执行，event loop终将进入 <strong>poll</strong> 阶段，在这个阶段等待 incoming connection, request 等等。但是，只要有被<code>setImmediate()</code>设定了回调，一旦 <strong>poll</strong> 阶段空闲，那么程序将结束 <strong>poll</strong> 阶段并进入 <strong>check</strong> 阶段，而不是继续等待 <strong>poll</strong> 事件们 （<strong>poll</strong> events）。</p>
<h4 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h4><p>如果一个 socket 或 handle 被突然关掉（比如 <code>socket.destroy()</code>），close事件将在这个阶段被触发，否则将通过<code>process.nextTick()</code>触发。</p>
<h3 id="event-loop的一个例子讲述"><a href="#event-loop的一个例子讲述" class="headerlink" title="event loop的一个例子讲述"></a>event loop的一个例子讲述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">function someAsyncOperation (callback) &#123;</span><br><span class="line">  // 假设这个任务要消耗 95ms</span><br><span class="line">  fs.readFile(&apos;/path/to/file&apos;, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var timeoutScheduled = Date.now();</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line"></span><br><span class="line">  var delay = Date.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  console.log(delay + &quot;ms have passed since I was scheduled&quot;);</span><br><span class="line">&#125;, 100);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// someAsyncOperation要消耗 95 ms 才能完成</span><br><span class="line">someAsyncOperation(function () &#123;</span><br><span class="line"></span><br><span class="line">  var startCallback = Date.now();</span><br><span class="line"></span><br><span class="line">  // 消耗 10ms...</span><br><span class="line">  while (Date.now() - startCallback &lt; 10) &#123;</span><br><span class="line">    ; // do nothing</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当event loop进入 <strong>poll</strong> 阶段，它有个空队列（<code>fs.readFile()</code>尚未结束）。所以它会等待剩下的毫秒，<br>直到最近的timer的下限时间到了。当它等了95ms，<code>fs.readFile()</code>首先结束了，然后它的回调被加到 <strong>poll</strong><br>的队列并执行——这个回调耗时10ms。之后由于没有其它回调在队列里，所以event loop会查看最近达到的timer的<br>下限时间，然后回到 <strong>timers</strong> 阶段，执行timer的回调。</p>
<p>所以在示例里，回调被设定 和 回调执行间的间隔是105ms。</p>
<h2 id="setImmediate-vs-setTimeout"><a href="#setImmediate-vs-setTimeout" class="headerlink" title="setImmediate() vs setTimeout()"></a><code>setImmediate()</code> vs <code>setTimeout()</code></h2><p><code>setImmediate()</code> 和 <code>setTimeout()</code>是相似的，区别在于什么时候执行回调：</p>
<ol>
<li><code>setImmediate()</code>被设计在 <strong>poll</strong> 阶段结束后立即执行回调；</li>
<li><code>setTimeout()</code>被设计在指定下限时间到达后执行回调。</li>
</ol>
<p>下面看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// timeout_vs_immediate.js</span><br><span class="line">setTimeout(function timeout () &#123;</span><br><span class="line">  console.log(&apos;timeout&apos;);</span><br><span class="line">&#125;,0);</span><br><span class="line"></span><br><span class="line">setImmediate(function immediate () &#123;</span><br><span class="line">  console.log(&apos;immediate&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>代码的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">timeout</span><br><span class="line">immediate</span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<p>是的，你没有看错，输出结果是 <strong>不确定</strong> 的！</p>
<p>从直觉上来说，<code>setImmediate()</code>的回调应该先执行，但为什么结果随机呢？</p>
<p>再看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// timeout_vs_immediate.js</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;timeout&apos;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">  setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;immediate&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<p>很好，<code>setImmediate</code>在这里永远先执行！</p>
<p>所以，结论是：</p>
<ol>
<li>如果两者都在主模块（main module）调用，那么执行先后取决于进程性能，即随机。</li>
<li>如果两者都不在主模块调用（即在一个 IO circle 中调用），那么<code>setImmediate</code>的回调永远先执行。</li>
</ol>
<p>那么又是为什么呢？</p>
<p>看<code>int uv_run(uv_loop_t* loop, uv_run_mode mode)</code>源码（deps/uv/src/unix/core.c#332）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123;</span><br><span class="line">  int timeout;</span><br><span class="line">  int r;</span><br><span class="line">  int ran_pending;</span><br><span class="line"></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line">  if (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line">  while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123;</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line">    //// 1. timer 阶段</span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line">    //// 2. I/O callbacks 阶段</span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    //// 3. idle/prepare 阶段</span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    // 重新更新timeout，使得 uv__io_poll 有机会跳出</span><br><span class="line">    timeout = 0;</span><br><span class="line">    if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line"></span><br><span class="line">    //// 4. poll 阶段</span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line">    //// 5. check 阶段</span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    //// 6. close 阶段</span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    if (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      // 7. UV_RUN_ONCE 模式下会再次检查timer</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (loop-&gt;stop_flag != 0)</span><br><span class="line">    loop-&gt;stop_flag = 0;</span><br><span class="line"></span><br><span class="line">  return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码看起来很清晰，一一对应了我们的几个阶段。</p>
<ul>
<li><ol>
<li>首先进入timer阶段，如果我们的机器性能一般，那么进入timer阶段时，1毫秒可能已经过去了（<code>setTimeout(fn, 0)</code> 等价于<code>setTimeout(fn, 1)</code>），那么<code>setTimeout</code>的回调会首先执行。</li>
</ol>
</li>
<li><ol start="2">
<li>如果没到一毫秒，那么我们可以知道，在check阶段，<code>setImmediate</code>的回调会先执行。</li>
</ol>
</li>
<li><ol start="3">
<li>为什么<code>fs.readFile</code>回调里设置的，<code>setImmediate</code>始终先执行？因为<code>fs.readFile</code>的回调执行是在 <strong>poll</strong> 阶段，所以，接下来的 <strong>check</strong> 阶段会先执行 <code>setImmediate</code> 的回调。</li>
</ol>
</li>
<li><ol start="4">
<li>我们可以注意到，<code>UV_RUN_ONCE</code>模式下，event loop会在开始和结束都去执行timer。</li>
</ol>
</li>
</ul>
<h2 id="理解-process-nextTick"><a href="#理解-process-nextTick" class="headerlink" title="理解 process.nextTick()"></a>理解 <code>process.nextTick()</code></h2><p>直到现在，我们才开始解释<code>process.nextTick()</code>。因为从技术上来说，它并不是event loop的一部分。相反的，<code>process.nextTick()</code>会把回调塞入<code>nextTickQueue</code>，<code>nextTickQueue</code>将在当前操作完成后处理，不管目前处于event loop的哪个阶段。</p>
<p>看看我们最初给的示意图，<code>process.nextTick()</code>不管在任何时候调用，都会在所处的这个阶段最后，在event loop进入下个阶段前，处理完所有<code>nextTickQueue</code>里的回调。</p>
<h3 id="process-nextTick-vs-setImmediate"><a href="#process-nextTick-vs-setImmediate" class="headerlink" title="process.nextTick() vs setImmediate()"></a><code>process.nextTick()</code> vs <code>setImmediate()</code></h3><p>两者看起来也类似，区别如下：</p>
<ul>
<li><ol>
<li><code>process.nextTick()</code>立即在本阶段执行回调；</li>
</ol>
</li>
<li><ol start="2">
<li><code>setImmediate()</code>只能在 <strong>check</strong> 阶段执行回调。</li>
</ol>
</li>
</ul>
<h4 id="文章转载于here"><a href="#文章转载于here" class="headerlink" title="文章转载于here"></a>文章转载于<a href="https://github.com/creeperyang/blog/issues/26">here</a></h4>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-08-09T05:24:32.368Z" itemprop="dateUpdated">2020-08-09 13:24:32</time>
</span><br>


        
        版权声明：本文为博主原创文章，转载请注明出处：<a href="/QiqiM.github.io/2020/06/05/深入js系列/深入理解Node事件循环/" target="_blank" rel="external">https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/</a>
        
    </div>
    
    <footer>
        <a href="https://github.com/QiqiM">
            <img src="/QiqiM.github.io/img/avatar1.jpg" alt="yato">
            yato
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/QiqiM.github.io/tags/JS/">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/QiqiM.github.io/tags/深入js系列/">深入js系列</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/&title=《什么是事件循环（Event Loop）》 — yato&pic=https://github.com/QiqiM/img/avatar1.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/&title=《什么是事件循环（Event Loop）》 — yato&source=勤学如春起之苗,不见其增,日有所长" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《什么是事件循环（Event Loop）》 — yato&url=https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/&via=https://github.com/QiqiM" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/QiqiM.github.io/2020/07/06/设计模式/原型模式/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">原型模式</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/QiqiM.github.io/2020/06/02/设计模式/简单工厂模式/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">简单工厂模式</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        赠人玫瑰，手有余香
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/QiqiM.github.io/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/QiqiM.github.io/img/wechat.png" data-alipay="/QiqiM.github.io/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/QiqiM.github.io/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>yato &copy; 2015 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/&title=《什么是事件循环（Event Loop）》 — yato&pic=https://github.com/QiqiM/img/avatar1.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/&title=《什么是事件循环（Event Loop）》 — yato&source=勤学如春起之苗,不见其增,日有所长" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《什么是事件循环（Event Loop）》 — yato&url=https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/&via=https://github.com/QiqiM" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://github.com/QiqiM/2020/06/05/深入js系列/深入理解Node事件循环/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/QiqiM.github.io/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
